{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"placetmachine Documenation","text":""},{"location":"machine/","title":"Machine documentation","text":""},{"location":"machine/#placetmachine.machine.Machine","title":"<code>Machine(**calc_options)</code>","text":"<p>A class used for controling the beamline in Placet.</p> <p>Uses Python interface to Placet (<code>Placet</code>) and  <code>Beamline</code> class for controling the beamline.</p> <p>Changes the logic of using the Placet for beam tracking. By default, the number  of the machines is set to 1. Each <code>Machine</code> instance corresponds to 1 actual beamline.  The beamline is described with <code>Beamline</code> object.  All the corrections are applied to the current machines with the current offsets by default.  Though, one can overwrite that with the typical survey functions, which violates the logic  of this class and also has to be used carefully.</p> <p>Attributes:</p> Name Type Description <code>placet</code> <code>Placet</code> <p>A <code>Placet</code> object, used for communicating with  the Placet process running in the background.</p> <code>console</code> <code>rich.console.Console</code> <p>An object used for the fancy terminal output.</p> <code>beamline</code> <code>Optional[Beamline]</code> <p>An object storing the beamline info.</p> <code>beams_invoked</code> <code>List[Beam]</code> <p>An object storing the beams that were created within current <code>Machine</code>.</p> <code>beamlines_invoked</code> <code>List[str]</code> <p>An object storing the names of the beamlines that were created within the current <code>Machine</code>.</p> <code>callback_struct_</code> <code>tuple(Callable, dict)</code> <p>The function that is used as callback for the tracking along with its parameters.</p> <code>_data_folder_</code> <code>str</code> <p>The name of the folder where the temporary files produced by Placet are stored.</p> <p>Other Parameters:</p> Name Type Description <code>debug_mode</code> <code>bool</code> <p>If <code>True</code> (default is <code>False</code>), runs <code>self.placet</code> in debug mode.</p> <code>save_logs</code> <code>bool</code> <p>If <code>True</code> (default is <code>True</code>), saves the execution logs by means of invoking  <code>save_debug_info</code> for <code>self.placet</code>.</p> <code>send_delay</code> <code>Optional[float]</code> <p>The time delay before each data transfer to a Placet process (sometimes needed for stability).</p> <code>console_output</code> <code>bool</code> <p>If <code>True</code> (default is <code>True</code>), prints the calculations progress in the console.</p> <code>show_intro</code> <code>bool</code> <p>If <code>True</code> (default is <code>True</code>), prints the welcome message of Placet at the start.</p>"},{"location":"machine/#placetmachine.machine.Machine.DFS","title":"<code>DFS(beam, survey=None, **extra_params)</code>","text":"<p>Perform the Dispersion Free Steering or DFS.</p> <p>Before actually invoking the  <code>Placet.TestMeasuredCorrection()</code> function, runs <code>Placet.Zero()</code>.</p> <p>If <code>bpms_realign</code> is <code>False</code> - the reference orbit will not be saved.  That means, that any further alignment will typically use BPMs center as  the best orbit solution (Eg. Rf alignment).  When it is <code>True</code>, runs the callback with 'BpmRealign' command.  After performing the DFS, sets the callback to <code>\"empty\"</code>.</p> <p>The default DFS parameters used: <pre><code>{\n        'beam0': beam,\n        'beam1': test_beam,\n        'cbeam0': test_beam_2,\n        'cbeam1': test_beam_3,\n        'survey': \"from_file\",\n        'machines': 1,\n        'wgt1': 3,\n        'bin_iteration': 1000,\n        'correct_full_bin': 1,\n        'binlength': 36,\n        'binoverlap': 18,\n        'bpm_res': 0.1,\n        'emitt_file': \"temp/emitt.dat\",\n\n        'timeout': 1000,\n        'errors_file': alignment_file\n}\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>beam</code> <code>Beam</code> <p>The beam to use.</p> required <code>survey</code> <code>Optional[str]</code> <p>The type of survey to be used. So far the accepted options are: <pre><code>[None, \"None\", \"Zero\", \"Clic\", \"Nlc\", \"Atl\", \n\"AtlZero\", \"Atl2\", \"AtlZero2, \"Earth\"]\n</code></pre></p> <ul> <li>If survey is <code>None</code> (default) - uses the current beamline alignment from  <code>self.beamline</code>.</li> <li>The rest value are Placet built-in surveys. After it is used, the alignment in <code>self.beamline</code> is going to be updated with new values generated by a survey.</li> </ul> <code>None</code> <p>Other Parameters:</p> Name Type Description <code>bpms_realign</code> <code>bool</code> <p>If <code>True</code> (default is <code>True</code>), updates the reference orbit (bpm reading) by  invoking a new callback procedure with <code>BpmRealign</code> in it.</p> <p>Other arguments accepted are inherited from  <code>Placet.TestMeasuredCorrection()</code>, except of <code>machines</code>, <code>survey</code>, and <code>beam</code>.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The tracking summary.</p> <p>The comlumns of the resulting DataFrame: <pre><code>['correction', 'beam', 'beamline', 'survey', 'positions_file', 'emittx', 'emitty']\n</code></pre></p>"},{"location":"machine/#placetmachine.machine.Machine.RF_align","title":"<code>RF_align(beam, survey=None, **extra_params)</code>","text":"<p>Perform the accelerating structures alignment (RF alignment).</p> <p>Does the correction with  <code>Placet.TestRfAlignment()</code>.  After, runs <code>Machine.track()</code> to evaluate the emittances.</p> <p>Parameters:</p> Name Type Description Default <code>beam</code> <code>Beam</code> <p>The beam to use.</p> required <code>survey</code> <code>Optional[str]</code> <p>The type of survey to be used. So far the accepted options are: <pre><code>[None, \"None\", \"Zero\", \"Clic\", \"Nlc\", \"Atl\", \n\"AtlZero\", \"Atl2\", \"AtlZero2, \"Earth\"]\n</code></pre></p> <ul> <li>If survey is <code>None</code> (default) - uses the current beamline alignment from  <code>self.beamline</code>.</li> <li>The rest value are Placet built-in surveys. After it is used, the alignment in <code>self.beamline</code> is going to be updated with new values generated by a survey.</li> </ul> <code>None</code> <p>Other arguments accepted are inherited from  <code>Placet.TestRfAlignment()</code>, except of <code>machines</code>, <code>survey</code>, and <code>beam</code>.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The tracking summary</p> <p>The comlumns of the resulting DataFrame: <pre><code>['correction', 'errors_seed', 'beam_seed', 'survey', 'positions_file', \n'emittx', 'emitty']\n</code></pre></p>"},{"location":"machine/#placetmachine.machine.Machine.apply_cavs_errors","title":"<code>apply_cavs_errors(phase_error=0.0, grad_error=0.0)</code>","text":"<p>Add the errors to the cavities' phases and gradients.</p> <p>Parameters:</p> Name Type Description Default <code>phase_error</code> <code>float</code> <p>Standard deviation of the phase (Absolue value).</p> <code>0.0</code> <code>grad_error</code> <code>float</code> <p>Standard deviation of the gradient (Absolue value).</p> <code>0.0</code>"},{"location":"machine/#placetmachine.machine.Machine.apply_knob","title":"<code>apply_knob(knob, amplitude, strategy, **extra_params)</code>","text":"<p>Apply the knob and update the beamline offsets.</p> <p>It is generaly safer to use this function instead of individual  <code>Knob.apply()</code>.  Here, the checks are performed to ensure that all the elements involved  in <code>knob</code> exist in <code>self.beamline</code>.</p> <p>Parameters:</p> Name Type Description Default <code>knob</code> <code>Knob</code> <p>The knob to use.</p> required <code>amplitude</code> <code>float</code> <p>Amplitude to apply.</p> required <code>strategy</code> <code>str</code> <p>Strategy to use for calculations of the offsets when the knob has <code>step_size</code>  defined. Default is 'simple_memory'.</p> required <p>Other Parameters:</p> Name Type Description <code>use_global_mismatch</code> <code>bool</code> <p>If <code>True</code> (default) coordinates' changes are evaluated to also compensate the possible mismatches caused by other knobs.</p>"},{"location":"machine/#placetmachine.machine.Machine.apply_quads_errors","title":"<code>apply_quads_errors(strength_error=0.0)</code>","text":"<p>Add the relative strength errors to all the  <code>Quadrupole</code>s in <code>self.beamline</code>.</p> <p>Parameters:</p> Name Type Description Default <code>strength_error</code> <code>float</code> <p>Standard relative deviation of the quadrupole strength.</p> <code>0.0</code>"},{"location":"machine/#placetmachine.machine.Machine.assign_errors","title":"<code>assign_errors(survey=None, **extra_params)</code>","text":"<p>Assign the alignment errors to the beamline currently used (<code>beamline</code> attribute). Uses provided <code>survey</code> along with the static errors given as keyword arguments. The <code>survey</code> acts as an instruction on how to misalign the lattice.</p> <p>There are several options to misalign the beamline using different built-int  misalignment surveys (accessed through <code>Machine.misalignment_surveys</code>): <pre><code>[\"default_clic\", \"from_file\", \"empty\", \"misalign_element\", \"misalign_elements\", \n\"misalign_girder\", \"misalign_girders\"]\n</code></pre> These surveys are implemented as Python functions and can be called outside of the score of this function.</p> <ul> <li><code>\"default_clic\"</code> corresponds to the function  <code>Machine.default_clic()</code> and applies the misalignments according to  <code>Placet.Clic()</code> survey.</li> <li><code>\"from_file\"</code> corresponds to the function <code>Machine.from_file()</code> and applies the misalignments from the file.</li> <li><code>\"empty\"</code> corresponds to the function <code>Machine.empty()</code> and does not apply any misalignments.</li> <li><code>\"misalign_element\"</code> corresponds to the function <code>Machine.misalign_element()</code> and  misaligns one element in the beamline.</li> <li><code>\"misalign_elements\"</code> corresponds to the function <code>Machine.misalign_element()</code> and  misaligns multiple element in the beamline.</li> <li><code>\"misalign_girder\"</code> corresponds to the function <code>Machine.misalign_girder()</code> and  misaligns one girder in the beamline.</li> <li><code>\"misalign_girders\"</code> corresponds to the function <code>Machine.misalign_girders()</code> and  misaligns multiple girders in the beamline.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>survey</code> <code>Optional[str]</code> <p>If survey is <code>None</code>, by default applying 'empty' survey.</p> <code>None</code> <p>Other Parameters:</p> Name Type Description <code>static_errors</code> <code>dict</code> <p>The dict containing the static errors of the lattice. This data is used when  invoking  <code>Machine.survey_errors_set()</code> Is required when using <code>\"default_clic\"</code> survey. All the possible settings are: <pre><code>['quadrupole_x', 'quadrupole_y', 'quadrupole_xp', 'quadrupole_yp', \n'quadrupole_roll', 'cavity_x', 'cavity_realign_x', 'cavity_y', \n'cavity_realign_y', 'cavity_xp', 'cavity_yp', 'cavity_dipole_x', \n'cavity_dipole_y', 'piece_x', 'piece_xp', 'piece_y', 'piece_yp', \n'bpm_x', 'bpm_y', 'bpm_xp', 'bpm_yp', 'bpm_roll', 'sbend_x', \n'sbend_y', 'sbend_xp', 'sbend_yp', 'sbend_roll']\n</code></pre></p> <code>errors_seed</code> <code>int</code> <p>The seed for errors sequence. If not defined, the random number is used.</p> <code>filename</code> <code>str</code> <p>When <code>\"from_file\"</code> survey is used, the <code>filename</code> is used to read the misalignments, otherwise ignored.</p> <p>Other keyword arguments accepted are the parameters of the  <code>Placet.InterGirderMove()</code>.</p>"},{"location":"machine/#placetmachine.machine.Machine.cavities_setup","title":"<code>cavities_setup(**extra_params)</code>","text":"<p>Set the main cavities parameters.</p> <p>It is required for the beam creation. Beams in Placet use the results from the command</p> <p><pre><code>% calc wake.dat\n</code></pre> to have the values for the transverse (longitudinal?) wakes.</p> <p>The <code>calc</code> function from the file <code>\"wake_calc.tcl\"</code> uses the functions from \"clic_beam.tcl\".  These functions utilize the global variable <code>structure'</code>. Thus, until these functions are substituted with Python alternatives, one has to call this function every time one sets the beamline. Moreover the macroparticles' weights are takendirectly from the file <code>\"wake.dat\"</code>.</p> <p>One has to provide all the other parameters. Having zeros as default could lead to unexpected behaviour.</p> <p>The variables <code>a</code>, <code>g</code>, <code>l</code>, <code>delta</code>, and <code>delta_g</code> are going to be declared in Placet in the form of structure by using <code>Placet.set_list()</code>.</p> <p>Other Parameters:</p> Name Type Description <code>a</code> <code>float</code> <p>to check</p> <code>g</code> <code>float</code> <p>to check</p> <code>l</code> <code>float</code> <p>to check</p> <code>delta</code> <code>float</code> <p>to check</p> <code>delta_g</code> <code>float</code> <p>to check</p> <code>phase</code> <code>float</code> <p>Cavities phase. Default is <code>0.0</code>.</p> <code>frac_lambda</code> <code>float</code> <p>to check. Default is <code>0.0</code>.</p> <code>scale</code> <code>float</code> <p>to check. Default is <code>1.0</code>.</p>"},{"location":"machine/#placetmachine.machine.Machine.create_beamline","title":"<code>create_beamline(lattice, **extra_params)</code>","text":"<p>Create the beamline in Placet from the input lattice file.</p> <p>The <code>beamline</code> attribute of <code>Machine</code> is going to be overwritten.</p> <p>Parameters:</p> Name Type Description Default <code>lattice</code> <code>str</code> <p>The name of the file containing the lattice.</p> required <p>Other Parameters:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the beamline (By default is set to <code>\"default\"</code>).</p> <code>callback</code> <code>bool</code> <p>If <code>True</code>(default is <code>True</code>) creates the callback procedure in Placet by invoking <code>set_callback()</code>.</p> <code>cavities_setup</code> <code>dict</code> <p>The dictionary containing the parameters for <code>cavities_setup()</code>.</p> <code>parser</code> <code>str</code> <p>The type of parser to be used to read the file into a <code>Beamline</code> object.  The possible options are described in <code>Beamline</code></p> <code>parser_variables</code> <code>dict</code> <p>The dict with the variables and their values that parser is going to use to parse the file. Can only be used with <code>\"advanced\"</code> parcer of <code>Beamline</code>.</p> <code>debug_mode</code> <code>bool</code> <p>If <code>True</code> (default is <code>False</code>), prints the information during the parsing processes.</p> <code>parse_for_placet</code> <code>bool</code> <p>[Only if <code>\"advanced\"</code> parser is used]. If <code>True</code> (default is <code>False</code>), feeds the parsed version  of the lattice saved with [<code>Beamline.to_placet()</code>] function. Otherwise, feeds the original file given in lattice.</p> <p>Returns:</p> Type Description <code>Beamline</code> <p>The created beamline.</p>"},{"location":"machine/#placetmachine.machine.Machine.default_clic","title":"<code>default_clic(**extra_params)</code>","text":"<p>Apply the default Clic survey to a lattice.</p> <p>The function calls <code>Clic</code> func in Placet. It requires the  lattice misalignments to be already declared with either with <code>Machine.survey_errors_set()</code> (preferred) or with  <code>self.placet.SurveyErrorSet()</code>.</p> <p>Can be used inside of a <code>proc</code> in Placet.</p> <p>Other Parameters:</p> Name Type Description <code>additional_lineskip</code> <code>int</code> <p>Can only take the value of '0' (default). If not given, the default values for the commands are used</p> <p>Other keyword arguments accepted are parameters of the <code>self.placet.InterGirderMove()</code> function, which is invoked within <code>default_clic</code>.</p>"},{"location":"machine/#placetmachine.machine.Machine.empty","title":"<code>empty(**extra_params)</code>","text":"<p>Apply the empty survey function.</p> <p>Corresponds to using <code>'None'</code> survey in Placet.</p> <p>Can be used inside of a <code>proc</code> in Placet.</p>"},{"location":"machine/#placetmachine.machine.Machine.eval_obs","title":"<code>eval_obs(beam, observables, **extra_params)</code>","text":"<p>Evaluate the requested observables for the current state of <code>self.beamline</code>.</p> <p>The observalbles could be the following:</p> <ul> <li>For particle beam: <pre><code>['E', 'x', 'y', 'z', 'px', 'py']\n</code></pre></li> <li>For macroparticle beam: <pre><code>['s', 'weight', 'E', 'x', 'px', 'y', 'py', 'sigma_xx', 'sigma_xpx', \n'sigma_pxpx', 'sigma_yy', 'sigma_ypy', 'sigma_pypy', 'sigma_xy', \n'sigma_xpy', 'sigma_yx', 'sigma_ypx']\n</code></pre> Also, emittance <code>['emittx', 'emitty']</code> is evaluted in each case.</li> </ul> <p>The units for the coordinates are: - <code>E</code>: GeV - <code>s(z)</code>, <code>x</code>, <code>y</code>, <code>z</code>: micrometer - <code>px</code>, <code>py</code>: microrad, - <code>emittx</code>, <code>emitty</code>: nm</p> <p>Parameters:</p> Name Type Description Default <code>beam</code> <code>Beam</code> <p>The beam to use.</p> required <code>observables</code> <code>Union[str, List[str]]</code> <p>The variables to read from the tracking data when performing the scan. It can consist of: <pre><code>['s', 'weight', 'E', 'x', 'px', 'y', 'py', 'sigma_xx', 'sigma_xpx', \n'sigma_pxpx', 'sigma_yy', 'sigma_ypy', 'sigma_pypy', 'sigma_xy', \n'sigma_xpy', 'sigma_yx', 'sigma_ypx', 'emittx', 'emitty']\n</code></pre> When more than 1 observable is needed, they should be passed as a list.</p> required <p>Other Parameters:</p> Name Type Description <code>suppress_output</code> <code>bool</code> <p>If <code>True</code> (default is <code>False</code>) suppresses the log message in regards of the tracking.</p> <p>Returns:</p> Type Description <code>List[float]</code> <p>The values of the observables.</p>"},{"location":"machine/#placetmachine.machine.Machine.eval_orbit","title":"<code>eval_orbit(beam)</code>","text":"<p>Evaluate the beam orbit based on the BPM readings.</p> <p>Parameters:</p> Name Type Description Default <code>beam</code> <code>Beam</code> <p>The beam to use.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>The orbit along the beamline.</p>"},{"location":"machine/#placetmachine.machine.Machine.eval_track_results","title":"<code>eval_track_results(beam, **extra_params)</code>","text":"<p>Evaluate the beam parameters at the beamline exit.</p> <p>At the beginning of the run, if the calculation requires performing the tracking, sets the callback. Depending on the beam type, the different callback is defined.  For sliced beam it is  <code>Machine.save_sliced_beam()</code>. For particle beam it is  <code>Machine.save_beam()</code>.</p> <p>The structure of the data in the files for the sliced beam: <pre><code>1. s long position along [um]\n2. weight\n3. energy [GeV]\n4. x [um]\n5. x' [um/m]\n6. y [um]\n7. y' [um/m]\n8. sigma_xx\n9. sigma_xx'\n10. sigma_x'x'\n11. sigma_yy\n12. sigma_yy'\n13. sigma_y'y'\n14. sigma_xy (always 0)\n15. 0\n16. 0\n17. 0\n</code></pre></p> <p>The structure of the data in the files for the particle beam: <pre><code>1. energy [GeV]\n2. x [um]\n3. y [um]\n4. z [um]\n5. x' [urad]\n6. y' [urad]\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>beam</code> <code>Beam</code> <p>The beam to use.</p> required <p>Other Parameters:</p> Name Type Description <code>keep_callback</code> <code>bool</code> <p>If <code>True</code> (default is <code>False</code>), does not change the callback function  at the end of the run.</p> <p>Returns:</p> Type Description <code>tuple(DataFrame, float, float)</code> <p>Returns the DataFrame with the particles' coordinates at the beamline exit  and final horizontal and vertical emittance.</p> <p>The columns of the DataFrame includes are:</p> <ul> <li>For sliced beam: <pre><code>['s', 'weight', 'E', 'x', 'px', 'y', 'py', 'sigma_xx', 'sigma_xpx', \n'sigma_pxpx', 'sigma_yy', 'sigma_ypy', 'sigma_pypy', 'sigma_xy', \n'sigma_xpy', 'sigma_yx', 'sigma_ypx']\n</code></pre></li> <li>For particle beam: <pre><code>['E', 'x', 'y', 'z', 'px', 'py']\n</code></pre></li> </ul>"},{"location":"machine/#placetmachine.machine.Machine.eval_twiss","title":"<code>eval_twiss(beam, **extra_params)</code>","text":"<p>Evaluate the Twiss parameters along the lattice.</p> <p>The method uses  <code>Placet.TwissPlotStep()</code>  function to evaluate the Twiss. </p> <p>(?) Apparently, it evaluates the twiss for error-free Lattice, or alternatively, for the current misalignments in the lattice.</p> <p>Parameters:</p> Name Type Description Default <code>beam</code> <code>Beam</code> <p>The beam to use.</p> required <p>Other Parameters:</p> Name Type Description <code>step</code> <code>float</code> <p>Step size to be taken for the calculation. If less than 0 the  parameters will be plotted only in the centres of the quadrupoles.</p> <code>start</code> <code>int</code> <p>(?) First particle for twiss computation.</p> <code>end</code> <code>int</code> <p>(?) Last particle for twiss computation</p> <code>list</code> <code>List[int]</code> <p>Save the twiss parameters only at the selected elements.</p> <code>file_read_only</code> <code>str</code> <p>When the parameter is given, the function just reads the Twiss  from this file and does not generate it.</p> <code>beamline</code> <code>str</code> <p>The beamline to be used in the calculations.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Returns a Pandas Dataframe with the Twiss data.</p> <p>The table contains the following columns: <pre><code>[\"id\", \"type\", \"s\", \"betx\", \"bety\", 'alfx', 'alfy', 'Dx', 'Dy', 'E']\n</code></pre></p>"},{"location":"machine/#placetmachine.machine.Machine.from_file","title":"<code>from_file(**extra_params)</code>","text":"<p>Apply the survey that uses the misalignments from the file.</p> <p>Other Parameters:</p> Name Type Description <code>file</code> <code>str</code> <p>The name of the file with the misalignments.</p> <code>additional_lineskip</code> <code>int</code> <p>Can only take the value of <code>0</code>. If not given, the default values for the commands are used.</p>"},{"location":"machine/#placetmachine.machine.Machine.import_beamline","title":"<code>import_beamline(lattice, **extra_params)</code>","text":"<p>Import the existing <code>Beamline</code> object as a beamline into Placet.</p> <p>Parameters:</p> Name Type Description Default <code>lattice</code> <code>Beamline</code> <p>The Beamline to import.</p> required <p>Other Parameters:</p> Name Type Description <code>callback</code> <code>bool</code> <p>If <code>True</code>(default is <code>True</code>) creates the callback procedure in Placet by invoking <code>set_callback()</code>.</p> <p>**!!Should be handled carefully! Some functions expect 'callback' procedure to exist. ** Eg. <code>eval_track_results()</code> evaluates  the macroparticles coordinates. To do so, 'callback' procedure is required.</p> <code>cavities_setup</code> <code>dict</code> <p>A dictionary containing the parameters for <code>cavities_setup()</code>.</p>"},{"location":"machine/#placetmachine.machine.Machine.iterate_knob","title":"<code>iterate_knob(beam, knob, observables, knob_range=[-1.0, 0.0, 1.0], **extra_params)</code>","text":"<p>Iterate the given knob in the given range and get the iteration summary.</p> <p>Saves the knob's state at the beginning of the iteration and restores it at the end.</p> <p>Parameters:</p> Name Type Description Default <code>beam</code> <code>Beam</code> <p>The name of the beam to be used.</p> required <code>knob</code> <code>Knob</code> <p>The knob to perform scan on.</p> required <code>observables</code> <code>Union[str, List[str]]</code> <p>The variables to read from the tracking data when performing the scan. It can consist of any combination of: <pre><code>['s', 'weight', 'E', 'x', 'px', 'y', 'py', 'sigma_xx', 'sigma_xpx', \n'sigma_pxpx', 'sigma_yy', 'sigma_ypy', 'sigma_pypy', 'sigma_xy', \n'sigma_xpy', 'sigma_yx', 'sigma_ypx', 'emittx', 'emitty']\n</code></pre> When more than 1 observable is needed, they should be passed as a list.</p> required <code>knob_range</code> <code>List[float]</code> <p>The list of the knob values to perform the scan.</p> <code>[-1.0, 0.0, 1.0]</code> <p>Other Parameters:</p> Name Type Description <code>iteration_type</code> <code>str</code> <p>The type of the knob iteration scan to perform. The possible options are  <pre><code>[\"natural\", \"with_cache\"]\n</code></pre> When it is \"with_cache\" (default), after each value from <code>knob_range</code> is applied the knob is reset to the initial state.  When it is \"natural\", the elements' offsets associated with a <code>knob</code> are not reset. Since <code>Knob.apply()</code> is additive function, an amplitude difference between the  previous and current is applied.</p> <code>knob_apply_strategy</code> <code>str</code> <p>Strategy to use for calculations of the offsets when knob has <code>step_size</code> defined.  Default is 'simple_memory'. Possible options are: <pre><code>[\"simple\", \"simple_memory\", \"min_scale\", \"min_scale_memory\"]\n</code></pre></p> <code>fit</code> <code>Callable</code> <p>Function to fit the data. !! Only works if the amound of observables is equaly 1.</p> <code>plot</code> <code>Callable</code> <p>Function to plot the iteration data. !! Only works if the amound of observables is equaly 1.</p> <code>use_global_mismatch</code> <code>bool</code> <p>If <code>True</code> (default) coordinates' changes are evaluated to also compensate the possible mismatches caused by other knobs. Only applicable to the strategies that memorize the mismatches, such as: <pre><code>['simple_memory', 'min_scale_memory']\n</code></pre></p> <p>Returns:</p> Type Description <code>dict</code> <p>The scan summary. The structure of the dictionary looks like this: <pre><code>{\n'scan_log': \n{\n'knob_range': knob_range, \n'obs_data': observable_values\n}, \n'fitted_value': ..,\n'best_obs': ..\n}\n</code></pre> <code>obs_data</code> follows the same format as the input variable <code>observables</code>. The data  stored there follows the shape: <pre><code>[[obs1_value1, obs2_value1, ..], [obs1_value2, obs2_value2, ..]]\n</code></pre> <code>fitted_value</code> is the best value estimated from the fit (if the fit function is given) and only 1 observable <code>best_obs</code> is the fitted function.</p>"},{"location":"machine/#placetmachine.machine.Machine.make_beam_many","title":"<code>make_beam_many(beam_name, n_slice, n, **extra_params)</code>","text":"<p>Generate the particle beam.</p> <p>Wraps <code>Beam.make_beam_many()</code>. Similar to <code>make_beam_many</code> from \"make_beam.tcl\" in Placet but rewritten in Python.</p> <p>Practically could pass the whole beam_setup to the function. Keep the same structure as in Placet. Optional parameters (if not given, checks self.beam_parameters. If self.beam_parameters does not have them throws an Exception)</p> <p>Parameters:</p> Name Type Description Default <code>beam_name</code> <code>str</code> <p>Name of the beam.</p> required <code>n_slice</code> <code>int</code> <p>Number of the slices.</p> required <code>n</code> <code>int</code> <p>Number of the particles per slice.</p> required <p>Other Parameters:</p> Name Type Description <code>sigma_z</code> <code>float</code> <p>[Required] Bunch length in micrometers.</p> <code>charge</code> <code>float</code> <p>[Required] Bunch charge.</p> <code>beta_x</code> <code>float</code> <p>[Required] Horizontal beta-function.</p> <code>beta_y</code> <code>float</code> <p>[Required] Vertical beta-function.</p> <code>alpha_x</code> <code>float</code> <p>[Required] Horizontal alpha-function.</p> <code>alpha_y</code> <code>float</code> <p>[Required] Vertical alpha-function.</p> <code>emitt_x</code> <code>float</code> <p>[Required] Horizontal normalized emittance.</p> <code>emitt_y</code> <code>float</code> <p>[Required] Vertical normalized emittance.</p> <code>e_spread</code> <code>float</code> <p>[Required] Energy spread.</p> <code>e_initial</code> <code>float</code> <p>[Required] Initial energy.</p> <code>n_total</code> <code>int</code> <p>[Required] Total number of the particles.</p> <p>Returns:</p> Type Description <code>str</code> <p>The beam name.</p>"},{"location":"machine/#placetmachine.machine.Machine.make_beam_slice_energy_gradient","title":"<code>make_beam_slice_energy_gradient(beam_name, n_slice, n_macroparticles, eng, grad, beam_seed=None, **extra_params)</code>","text":"<p>Generate the macroparticle (sliced) beam.</p> <p>Wraps <code>Beam.make_beam_slice_energy_gradient()</code>. Similar to <code>make_beam_slice_energy_gradient</code>from \"make_beam.tcl\" in Placet but rewritten in Python.</p> <p>Parameters:</p> Name Type Description Default <code>beam_name</code> <code>str</code> <p>Name of the beam.</p> required <code>n_slice</code> <code>int</code> <p>Number of the slices.</p> required <code>n_macroparticles</code> <code>int</code> <p>Number of the macroparticles per slice.</p> required <code>eng</code> <code>float</code> <p>Initial energy offset.</p> required <code>grad</code> <code>float</code> <p>Accelerating gradient offset.</p> required <code>beam_seed</code> <code>Optional[int]</code> <p>The seed number of the random number distribution. If not given a random number in the range [1, 1000000] is taken.</p> <code>None</code> <p>Other Parameters:</p> Name Type Description <code>sigma_z</code> <code>float</code> <p>[Required] Bunch length in micrometers.</p> <code>charge</code> <code>float</code> <p>[Required] Bunch charge.</p> <code>beta_x</code> <code>float</code> <p>[Required] Horizontal beta-function.</p> <code>beta_y</code> <code>float</code> <p>[Required] Vertical beta-function.</p> <code>alpha_x</code> <code>float</code> <p>[Required] Horizontal alpha-function.</p> <code>alpha_y</code> <code>float</code> <p>[Required] Vertical alpha-function.</p> <code>emitt_x</code> <code>float</code> <p>[Required] Horizontal normalized emittance.</p> <code>emitt_y</code> <code>float</code> <p>[Required] Vertical normalized emittance.</p> <code>e_spread</code> <code>float</code> <p>[Required] Energy spread.</p> <code>e_initial</code> <code>float</code> <p>[Required] Initial energy.</p> <code>n_total</code> <code>int</code> <p>[Required] Total number of the particles.</p> <p>Returns:</p> Type Description <code>str</code> <p>The beam name.</p>"},{"location":"machine/#placetmachine.machine.Machine.misalign_articulation_point","title":"<code>misalign_articulation_point(**extra_params)</code>","text":"<p>Offset the articulation point either between 2 girders or at the beamline start/end.</p> <p>The girders and elements on them are misalligned accordingly (wrt the geometry of the girder).</p> <p>There is an option to provide the ids of the girders to the right and to the left of the articulation point. That  require <code>girder_right</code> - <code>girder_left</code> to be equal 1, otherwise an exception will be raised.</p> <p>It is possible to provide only 1 id either of the right or the left one. This also works for the start/end of the beamline.</p> <p>Other Parameters:</p> Name Type Description <code>girder_left</code> <code>Optional[int]</code> <p>The ID of the girder to the left of the articulation point.</p> <code>girder_right</code> <code>Optional[int]</code> <p>The ID of the girder to the right of the articulation point.</p> <code>x</code> <code>float</code> <p>The horizontal offset in micrometers. Default is <code>0.0</code>.</p> <code>y</code> <code>float</code> <p>The vertical offset in micrometers. Default is <code>0.0</code>.</p> <code>filter_types</code> <code>Optional[List[str]]</code> <p>The types of elements to apply the misalignments to. By default, the misalignments are applied to all the elements on the girder.</p>"},{"location":"machine/#placetmachine.machine.Machine.misalign_element","title":"<code>misalign_element(**extra_params)</code>","text":"<p>Apply the geometrical misalignments to the element with the given ID.</p> <p>Duplicates  <code>Beamline.misalign_element()</code>.</p> <p>Other Parameters:</p> Name Type Description <code>element_index</code> <code>int</code> <p>The id of the element in the lattice. Required</p> <code>x</code> <code>float</code> <p>The horizontal offset in micrometers. Default is <code>0.0</code>.</p> <code>xp</code> <code>float</code> <p>The horizontal angle in micrometers/m. Default is <code>0.0</code>.</p> <code>y</code> <code>float</code> <p>The vertical offset in micrometers. Default is <code>0.0</code>.</p> <code>yp</code> <code>float</code> <p>The vertical angle in micrometers/m. Default is <code>0.0</code>.</p> <code>roll</code> <code>float</code> <p>The roll angle in microrad. Default is <code>0.0</code>.</p>"},{"location":"machine/#placetmachine.machine.Machine.misalign_elements","title":"<code>misalign_elements(**extra_params)</code>","text":"<p>Apply the geometrical misalignments to the elements in the dictionary</p> <p>Other Parameters:</p> Name Type Description <code>offsets_data</code> <code>dict</code> <p>[Required] The dictionary with the elements offsets  in the following format: <pre><code>{\n'element_id1': {\n'x': ..\n'y': ..\n..\n}\n'element_id2': {\n..\n}\n..\n}\n</code></pre></p>"},{"location":"machine/#placetmachine.machine.Machine.misalign_girder","title":"<code>misalign_girder(**extra_params)</code>","text":"<p>Offset the girder transversaly together with the elements on it.</p> <p>All the elements on the girder are equally misaligned.</p> <p>Other Parameters:</p> Name Type Description <code>girder</code> <code>int</code> <p>The girder ID.</p> <code>filter_types</code> <code>Optional[List(str)]</code> <p>The types of elements to apply the misalignments to. By default, the misalignments are applied to all the elements on the girder.</p> <code>x</code> <code>float</code> <p>The horizontal offset in micrometers.</p> <code>y</code> <code>float</code> <p>The vertical offset in micrometers.</p>"},{"location":"machine/#placetmachine.machine.Machine.misalign_girder_general","title":"<code>misalign_girder_general(**extra_params)</code>","text":"<p>Misalign the girder by means of moving its end points.</p> <p>Other Parameters:</p> Name Type Description <code>girder</code> <code>int</code> <p>[Required] The id of the girder.</p> <code>x_right</code> <code>float</code> <p>The horizontal offset in micrometers of right end-point. Default is <code>0.0</code>.</p> <code>y_right</code> <code>float</code> <p>The vertical offset in micrometers of the right end-point. Default is <code>0.0</code>.</p> <code>x_left</code> <code>float</code> <p>The horizontal offset in micrometers of left end-point. Default is <code>0.0</code>.</p> <code>y_left</code> <code>float</code> <p>The vertical offset in micrometers of the left end-point. Default is <code>0.0</code>.</p> <code>filter_types</code> <code>Optional[List[str]]</code> <p>The types of elements to apply the misalignments to. By default, the misalignments are applied to all the elements on the girder.</p>"},{"location":"machine/#placetmachine.machine.Machine.misalign_girders","title":"<code>misalign_girders(**extra_params)</code>","text":"<p>Misalign the girders according to the dictionary.</p> <p>Other Parameters:</p> Name Type Description <code>offsets_data</code> <code>dict</code> <p>The dictionary with the girders offsets in the following format: <pre><code>{\n'girder_id1': {\n'x': ..\n'y': ..\n..\n}\n'girder_id2':{\n..\n}\n..\n}\n</code></pre></p> <code>filter_types</code> <code>Optional[List[str]]</code> <p>The types of elements to apply the misalignments to. By default, the misalignments are applied to all the elements on the girder.</p>"},{"location":"machine/#placetmachine.machine.Machine.one_2_one","title":"<code>one_2_one(beam, survey=None, **extra_params)</code>","text":"<p>Perform the one-to-one (1-2-1) alignment.</p> <p>It is a wrapped version of  <code>Placet.TestSimpleCorrection()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>beam</code> <code>Beam</code> <p>The beam to use.</p> required <code>survey</code> <code>Optional[str]</code> <p>The type of survey to be used. So far the accepted options are: <pre><code>[None, \"None\", \"Zero\", \"Clic\", \"Nlc\", \"Atl\", \n\"AtlZero\", \"Atl2\", \"AtlZero2, \"Earth\"]\n</code></pre></p> <ul> <li>If survey is <code>None</code> (default) - uses the current beamline alignment from  <code>self.beamline</code>.</li> <li>The rest value are Placet built-in surveys. After it is used, the alignment in <code>self.beamline</code> is going to be updated with new values generated by a survey.</li> </ul> <code>None</code> <p>Other arguments accepted are inherited from  <code>Placet.TestSimpleCorrection()</code>, except of <code>machines</code>, <code>survey</code>, and <code>beam</code>.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The tracking summary after the correction.</p> <p>The columns of the resulting DataFrame: <pre><code>['correction', 'beam', 'beamline', 'survey', 'positions_file', 'emittx', 'emitty']\n</code></pre></p>"},{"location":"machine/#placetmachine.machine.Machine.phase_advance","title":"<code>phase_advance(start_id, end_id)</code>","text":"<p>Get the phase advance</p> <p>Does not work atm.</p> <p>Parameters:</p> Name Type Description Default <code>start_id</code> <code>int</code> <p>Element index of the first element</p> required <code>end_id</code> <code>int</code> <p>Element index of the last element</p> required"},{"location":"machine/#placetmachine.machine.Machine.random_reset","title":"<code>random_reset(seed=None)</code>","text":"<p>Reset the random seed in Placet.</p> <p>Runs <code>Placet.RandomReset()</code>.</p>"},{"location":"machine/#placetmachine.machine.Machine.save_beam","title":"<code>save_beam(**extra_params)</code>","text":"<p>Save the particle beam.</p> <p>Can be used inside of a <code>proc</code> in Placet.</p> <p>Other keyword arguments accepted are parameters of the <code>self.placet.BeamDump()</code> function, which is invoked within <code>save_beam</code>.</p>"},{"location":"machine/#placetmachine.machine.Machine.save_sliced_beam","title":"<code>save_sliced_beam(**extra_params)</code>","text":"<p>Save the sliced beam.</p> <p>Other keyword arguments accepted are parameters of the <code>self.placet.BeamSaveAll()</code> function, which is invoked within <code>save_sliced_beam</code>.</p>"},{"location":"machine/#placetmachine.machine.Machine.scan_knob","title":"<code>scan_knob(beam, knob, observable, knob_range, fit_func, **extra_params)</code>","text":"<p>Scan the given knob in the given range, apply the fit function and set the  knob value to the optimum.</p> <p>Since, the optimal value is set only in <code>self.beamline</code>, in case one needs to update these values in Placet immediatly, one has to call <code>Machine._update_lattice_misalignments()</code></p> <p>Parameters:</p> Name Type Description Default <code>beam</code> <code>Beam</code> <p>The beam used for the scan.</p> required <code>knob</code> <code>Knob</code> <p>The knob to perform scan on.</p> required <code>knob_range</code> <code>List[float]</code> <p>The list of the knob values to perform the scan.</p> required <code>observable</code> <code>str</code> <p>The variables to read from the tracking data and use it for identifying the optimum in the scan. It can be one of: <pre><code>['s', 'weight', 'E', 'x', 'px', 'y', 'py', 'sigma_xx', 'sigma_xpx', \n'sigma_pxpx', 'sigma_yy', 'sigma_ypy', 'sigma_pypy', 'sigma_xy', \n'sigma_xpy', 'sigma_yx', 'sigma_ypx', 'emittx', 'emitty']\n</code></pre></p> required <code>fit_func</code> <code>Callable</code> <p>The fit function for the data.</p> required <p>Other Parameters:</p> Name Type Description <code>plot</code> <code>Callable[[List[float], List[float]], None]</code> <p>The function to plot the knob iteration of the format f(x, y).</p> <code>evaluate_optimal</code> <code>bool</code> <p>If <code>True</code> (default is <code>True</code>) reevaluates the emittance by running <code>track()</code> function.</p> <code>iteration_type</code> <code>str</code> <p>The type of the knob iteration scan to perform. The possible options are  <pre><code>[\"natural\", \"with_cache\"]\n</code></pre> When it is \"with_cache\" (default), after each value from <code>knob_range</code> is applied the knob is reset to the initial state.  When it is \"natural\", the elements' offsets associated with a <code>knob</code> are not reset. Since <code>Knob.apply()</code> is additive function, an amplitude difference between the  previous and current is applied.</p> <code>knob_apply_strategy</code> <code>str</code> <p>Strategy to use for calculations of the offsets when knob has <code>step_size</code> defined.  Default is 'simple_memory'. Possible options are: <pre><code>[\"simple\", \"simple_memory\", \"min_scale\", \"min_scale_memory\"]\n</code></pre></p> <code>minimization</code> <code>bool</code> <p>If <code>True</code> (default) the goal of the function is the minimization of the provided <code>observable</code>. If <code>False</code> - maximization of <code>observable</code>. This is needed to evaluate the best value of <code>observable</code> in case the fitted value is not smallest/largest.</p> <code>use_global_mismatch</code> <code>bool</code> <p>If <code>True</code> (default) coordinates' changes are evaluated to also compensate the possible mismatches caused by other knobs. Only applicable to the strategies that memorize the mismatches, such as: <pre><code>['simple_memory', 'min_scale_memory']\n</code></pre></p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The scan summary. The columns of the output table are: <pre><code>['correction', 'positions_file', 'emittx', 'emitty', 'knob_value', 'scan_log']\n</code></pre></p>"},{"location":"machine/#placetmachine.machine.Machine.set_callback","title":"<code>set_callback(func, **extra_params)</code>","text":"<p>Set the callback function for the tracking.</p> <p>By default, when a <code>Beamline</code> is created within <code>Machine</code>, a callback procedure is declared with <code>TclCall</code>. This procedure is going to be called every time the beam tracking through the beamline is performed.  The name of this procedure is set to <code>'callback'</code>. After the beamline creation the name of the function cannot be changed, but the actual procedure can be overwritten in Placet. And this is what this function does.</p> <p>It is primaraly used for saving the macroparticle and particle beams' distributions. Normally, one does not have to call it, but use the other function that set it  automatically.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>Function for the callback.</p> required <p>Other parameters could be any keyword argument that the input <code>func</code> accepts.</p>"},{"location":"machine/#placetmachine.machine.Machine.survey_errors_set","title":"<code>survey_errors_set(**extra_params)</code>","text":"<p>Set the default errors for the Placet surveys.</p> <p>Overwrites the <code>Placet.SurveyErrorSet()</code>  and sets the values not provided by the user to zero by default. Original  <code>Placet.SurveyErrorSet()</code> only overwrites  the values provided by the user, not touching the rest.</p> <p>Other parameters are the same as for <code>Placet.SurveyErrorSet()</code>. The full list: <pre><code>['quadrupole_x', 'quadrupole_y', 'quadrupole_xp', 'quadrupole_yp', 'quadrupole_roll', \n'cavity_x', 'cavity_realign_x', 'cavity_y', 'cavity_realign_y', 'cavity_xp', \n'cavity_yp', 'cavity_dipole_x', 'cavity_dipole_y', 'piece_x', 'piece_xp', 'piece_y', \n'piece_yp', 'bpm_x', 'bpm_y', 'bpm_xp', 'bpm_yp', 'bpm_roll', 'sbend_x', 'sbend_y', \n'sbend_xp', 'sbend_yp', 'sbend_roll']\n</code></pre> Refer to <code>Placet.SurveyErrorSet()</code> for more details.</p>"},{"location":"machine/#placetmachine.machine.Machine.track","title":"<code>track(beam, survey=None)</code>","text":"<p>Perform the tracking without applying any corrections.</p> <p>It is a wrapped version of  <code>Placet.TestNoCorrection()</code>. When <code>survey</code> parameter is not provided (Recommended), the current misalignments in <code>self.beamline</code> are used. This is important, because  <code>Placet.TestNoCorrection()</code> does not offer such capabilities. It can only misalign the lattice according to some guidelines and ignores the misalignmenst prior to calling. </p> <p><code>Machine.track()</code> on the other hand relies on the data stored in <code>self.beamline</code>.  So, to overcome the limitation of <code>Placet.TestNoCorrection()</code> the default survey is set to <code>\"from_file\"</code> and the file used is the one produced for the current state of <code>self.beamline</code>.</p> <p>[!!] Be aware that Placet internally does not generate random numbers, but rather  takes pseudo random numbers from the sequence, uniquely defined by a seed value. So, if you run your <code>Machine</code> program with a Placet built-in surveys there is alway a chance you are going to get the same offsets sequence. To make sure that misalignments are different one has to run <code>Placet.RandomReset</code> before the tracking with surveys. In <code>Machine.assign_errors()</code> for example, this is invoked by default (set to a random value) if the <code>error_seed</code> parameter is not declared.</p> <p>Parameters:</p> Name Type Description Default <code>beam</code> <code>Beam</code> <p>The beam to use.</p> required <code>survey</code> <code>Optional[str]</code> <p>The type of survey to be used. So far the accepted options are: <pre><code>[None, \"None\", \"Zero\", \"Clic\", \"Nlc\", \"Atl\", \n\"AtlZero\", \"Atl2\", \"AtlZero2, \"Earth\"]\n</code></pre></p> <ul> <li>If survey is <code>None</code> (default) - uses the current beamline alignment from  <code>self.beamline</code>.</li> <li>The rest value are Placet built-in surveys. After it is used, the alignment in <code>self.beamline</code> is going to be updated with new values generated by a survey.</li> </ul> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The tracking summary.</p> <p>The columns of the resulting DataFrame: <pre><code>['correction', 'beam', 'beamline', 'survey', 'positions_file', 'emittx', 'emitty']\n</code></pre></p>"},{"location":"beam/beam/","title":"Beam documentation","text":""},{"location":"beam/beam/#placetmachine.beam.beam.Beam","title":"<code>Beam(beam_name, placet, beam_type=None)</code>","text":"<p>A class to handle the beams in Placet.</p> <p>The default routine to create the particle beam is  <code>Beam.make_beam_many()</code>. The default routine to create the sliced beam is  <code>Beam.make_beam_slice_energy_gradient()</code>.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the beam.</p> <code>placet</code> <code>Placet</code> <p>The <code>Placet</code> object to control the beam creation in Placet.</p> <code>beam_type</code> <code>str</code> <p>The type of beam. The possible options are: <pre><code>[\"sliced\", \"partice\", None]\n</code></pre></p> <code>_data_folder_</code> <code>str</code> <p>The name of the folder where the temporary files produced by Placet are stored.</p> <p>name         The name of the beam to create. placet          Placet process to create the beam in. beam_type         The type of beam to create. The possible options it accepts:         <pre><code>[\"sliced\", \"partice\", None]\n</code></pre>         First 2 are valid options for Placet, <code>None</code> is for testing only.</p>"},{"location":"beam/beam/#placetmachine.beam.beam.Beam.make_beam_many","title":"<code>make_beam_many(n_slice, n, **extra_params)</code>","text":"<p>Generate the particle beam.</p> <p>Similar to <code>make_beam_many</code> from \"make_beam.tcl\" in Placet but rewritten in Python.</p> <p>Practically could pass the whole beam_setup to the function. Keep the same structure as in Placet. Optional parameters (if not given, checks self.beam_parameters. If self.beam_parameters does not have them throws an Exception)</p> <p>Parameters:</p> Name Type Description Default <code>beam_name</code> <p>Name of the beam.</p> required <code>n_slice</code> <code>int</code> <p>Number of the slices.</p> required <code>n</code> <code>int</code> <p>Number of the particles per slice.</p> required <p>Other Parameters:</p> Name Type Description <code>sigma_z</code> <code>float</code> <p>[Required] Bunch length in micrometers.</p> <code>charge</code> <code>float</code> <p>[Required] Bunch charge.</p> <code>beta_x</code> <code>float</code> <p>[Required] Horizontal beta-function.</p> <code>beta_y</code> <code>float</code> <p>[Required] Vertical beta-function.</p> <code>alpha_x</code> <code>float</code> <p>[Required] Horizontal alpha-function.</p> <code>alpha_y</code> <code>float</code> <p>[Required] Vertical alpha-function.</p> <code>emitt_x</code> <code>float</code> <p>[Required] Horizontal normalized emittance.</p> <code>emitt_y</code> <code>float</code> <p>[Required] Vertical normalized emittance.</p> <code>e_spread</code> <code>float</code> <p>[Required] Energy spread.</p> <code>e_initial</code> <code>float</code> <p>[Required] Initial energy.</p> <code>n_total</code> <code>int</code> <p>[Required] Total number of the particles.</p> <p>Returns:</p> Type Description <code>str</code> <p>The beam name.</p>"},{"location":"beam/beam/#placetmachine.beam.beam.Beam.make_beam_slice_energy_gradient","title":"<code>make_beam_slice_energy_gradient(n_slice, n_macroparticles, eng, grad, beam_seed=None, **extra_params)</code>","text":"<p>Generate the macroparticle (sliced) beam.</p> <p>Similar to <code>make_beam_slice_energy_gradient</code>from \"make_beam.tcl\" in Placet but rewritten in Python.</p> <p>Parameters:</p> Name Type Description Default <code>beam_name</code> <p>Name of the beam.</p> required <code>n_slice</code> <code>int</code> <p>Number of the slices.</p> required <code>n_macroparticles</code> <code>int</code> <p>Number of the macroparticles per slice.</p> required <code>eng</code> <code>float</code> <p>Initial energy offset.</p> required <code>grad</code> <code>float</code> <p>Accelerating gradient offset.</p> required <code>beam_seed</code> <code>Optional[int]</code> <p>The seed number of the random number distribution. If not given a random number in the range [1, 1000000] is taken.</p> <code>None</code> <p>Other Parameters:</p> Name Type Description <code>sigma_z</code> <code>float</code> <p>[Required] Bunch length in micrometers.</p> <code>charge</code> <code>float</code> <p>[Required] Bunch charge.</p> <code>beta_x</code> <code>float</code> <p>[Required] Horizontal beta-function.</p> <code>beta_y</code> <code>float</code> <p>[Required] Vertical beta-function.</p> <code>alpha_x</code> <code>float</code> <p>[Required] Horizontal alpha-function.</p> <code>alpha_y</code> <code>float</code> <p>[Required] Vertical alpha-function.</p> <code>emitt_x</code> <code>float</code> <p>[Required] Horizontal normalized emittance.</p> <code>emitt_y</code> <code>float</code> <p>[Required] Vertical normalized emittance.</p> <code>e_spread</code> <code>float</code> <p>[Required] Energy spread.</p> <code>e_initial</code> <code>float</code> <p>[Required] Initial energy.</p> <code>n_total</code> <code>int</code> <p>[Required] Total number of the particles.</p> <p>Returns:</p> Type Description <code>str</code> <p>The beam name.</p>"},{"location":"beam/beam/#placetmachine.beam.beam.Beam.offset_beam","title":"<code>offset_beam(**extra_params)</code>","text":"<p>Add the transverse offset, transverse angle or roll angle to the  current beam.</p> <p>Other Parameters:</p> Name Type Description <code>x</code> <code>float</code> <p>Horizontal offset in micrometers.</p> <code>y</code> <code>float</code> <p>Vertical offset in micrometers.</p> <code>angle_x</code> <code>float</code> <p>Horizontal angle in microradians.</p> <code>angle_y</code> <code>float</code> <p>Vertical angle in microradians.</p> <code>rotate</code> <code>float</code> <p>Roll angle in radians. It is added after the offsets.</p> <code>start</code> <code>int</code> <p>First particle to offset.</p> <code>end</code> <code>int</code> <p>Last particle to offset.</p>"},{"location":"examples/example1/","title":"Example 1","text":""},{"location":"lattice/bpm/","title":"Bpm documentation","text":""},{"location":"lattice/bpm/#placetmachine.lattice.bpm.Bpm","title":"<code>Bpm(in_parameters=None, index=None)</code>","text":"<p>         Bases: <code>Element</code></p> <p>A class used to store the BPM information.</p> <p>Attributes:</p> Name Type Description <code>settings</code> <code>dict</code> <p>Dictionary containing the element settings.</p> <code>girder</code> <code>Optional[Girder]</code> <p>The girder reference the <code>Element</code> is placed on. This parameter is only relevant when being the part of the lattice. Upon creation is set to <code>None</code>.</p> <code>type</code> <code>str</code> <p>The type of the element. It is set to \"Bpm\".</p> <p>The list of acceptable settings: <pre><code>[\"name\", \"comment\", \"s\", \"x\", \"y\", \"xp\", \"yp\", \"roll\", \"tilt\", \"tilt_deg\", \n\"length\", \"synrad\", \"six_dim\", \"thin_lens\", \"e0\", \"aperture_x\", \"aperture_y\", \n\"aperture_losses\", \"aperture_shape\", \"tclcall_entrance\", \"tclcall_exit\", \n\"short_range_wake\", \"resolution\", \"reading_x\", \"reading_y\", \n\"transmitted_charge\", \"scale_x\", \"scale_y\", \"store_bunches\", \"hcorrector\", \n\"hcorrector_step_size\", \"vcorrector\", \"vcorrector_step_size\"]\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>in_parameters</code> <code>Optional[dict]</code> <p>The dict with input settings.</p> <code>None</code> <code>girder</code> <p>The number of the girder element is placed.</p> required <code>index</code> <code>Optional[int]</code> <p>The index of the element in the lattice.</p> <code>None</code>"},{"location":"lattice/cavity/","title":"Cavity documentation","text":""},{"location":"lattice/cavity/#placetmachine.lattice.cavity.Cavity","title":"<code>Cavity(in_parameters=None, index=None, **extra_params)</code>","text":"<p>         Bases: <code>Element</code></p> <p>A class used to store the cavity information.</p> <p>Attributes:</p> Name Type Description <code>settings</code> <code>dict</code> <p>Dictionary containing the element settings.</p> <code>girder</code> <code>Optional[Girder]</code> <p>The girder reference the <code>Element</code> is placed on. This parameter is only relevant when being the part of the lattice. Upon creation is set to <code>None</code>.</p> <code>type</code> <code>str</code> <p>The type of the element. It is set to \"Cavity\".</p> <p>The list of acceptable settings: <pre><code>[\"name\", \"comment\", \"s\", \"x\", \"y\", \"xp\", \"yp\", \"roll\", \"tilt\", \"tilt_deg\", \n\"length\", \"synrad\", \"six_dim\", \"thin_lens\", \"e0\", \"aperture_x\", \"aperture_y\", \n\"aperture_losses\", \"aperture_shape\", \"tclcall_entrance\", \"tclcall_exit\", \n\"short_range_wake\", \"gradient\", \"phase\", \"type\", \"lambda\", \"frequency\", \n\"bookshelf_x\", \"bookshelf_y\", \"bookshelf_phase\", \"bpm_offset_x\", \"bpm_offset_y\", \n\"bpm_reading_x\", \"bpm_reading_y\", \"dipole_kick_x\", \"dipole_kick_y\", \"pi_mode\"]\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>in_parameters</code> <code>Optional[dict]</code> <p>The dict with input settings.</p> <code>None</code> <code>girder</code> <p>The number of the girder element is placed.</p> required <code>index</code> <code>Optional[int]</code> <p>The index of the element in the lattice.</p> <code>None</code> <p>Other Parameters:</p> Name Type Description <code>angle</code> <code>bool</code> <p>If <code>True</code> (default is <code>True</code>), the phase is given in degrees, otherwise radians.</p>"},{"location":"lattice/cavity/#placetmachine.lattice.cavity.Cavity.to_placet","title":"<code>to_placet()</code>","text":"<p>Convert the element to a Placet readable format.</p> <p>Returns:</p> Type Description <code>str</code> <p>The string containing the element</p>"},{"location":"lattice/dipole/","title":"Dipole documentation","text":""},{"location":"lattice/dipole/#placetmachine.lattice.dipole.Dipole","title":"<code>Dipole(in_parameters=None, index=None)</code>","text":"<p>         Bases: <code>Element</code></p> <p>A class used to store the dipole information.</p> <p>Attributes:</p> Name Type Description <code>settings</code> <code>dict</code> <p>Dictionary containing the element settings.</p> <code>girder</code> <code>Optional[Girder]</code> <p>The girder reference the <code>Element</code> is placed on. This parameter is only relevant when being the part of the lattice. Upon creation is set to <code>None</code>.</p> <code>type</code> <code>str</code> <p>The type of the element. It is set to \"Dipole\".</p> <p>The list of acceptable settings: <pre><code>[\"name\", \"s\", \"x\", \"y\", \"xp\", \"yp\", \"roll\", \"length\", \"synrad\", \"six_dum\", \n\"thin_lens\", \"e0\", \"aperture_x\", \"aperture_y\", \"aperture_losses\", \n\"aperture_shape\", \"strength_x\", \"strength_y\", \"hcorrector\", \n\"hcorrector_step_size\", \"vcorrector\", \"vcorrector_step_size\", \"tclcall_entrance\", \n\"tclcall_exit\", \"short_range_wake\"]\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>in_parameters</code> <code>Optional[dict]</code> <p>The dict with input settings.</p> <code>None</code> <code>girder</code> <p>The number of the girder element is placed.</p> required <code>index</code> <code>Optional[int]</code> <p>The index of the element in the lattice.</p> <code>None</code>"},{"location":"lattice/drift/","title":"Drift documentation","text":""},{"location":"lattice/drift/#placetmachine.lattice.drift.Drift","title":"<code>Drift(in_parameters=None, index=None)</code>","text":"<p>         Bases: <code>Element</code></p> <p>A class used to store the drift information.</p> <p>Attributes:</p> Name Type Description <code>settings</code> <code>dict</code> <p>Dictionary containing the element settings.</p> <code>girder</code> <code>Optional[Girder]</code> <p>The girder reference the <code>Element</code> is placed on. This parameter is only relevant when being the part of the lattice. Upon creation is set to <code>None</code>.</p> <code>type</code> <code>str</code> <p>The type of the element. It is set to \"Drift\".</p> <p>The list of acceptable settings: <pre><code>[\"name\", \"comment\", \"s\", \"x\", \"y\", \"xp\", \"yp\", \"roll\", \"tilt\", \"tilt_deg\", \n\"length\", \"synrad\", \"six_dim\", \"thin_lens\", \"e0\", \"aperture_x\", \"aperture_y\", \n\"aperture_losses\", \"aperture_shape\", \"tclcall_entrance\", \"tclcall_exit\", \n\"short_range_wake\"]\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>in_parameters</code> <code>Optional[dict]</code> <p>The dict with input settings.</p> <code>None</code> <code>girder</code> <p>The number of the girder element is placed.</p> required <code>index</code> <code>Optional[int]</code> <p>The index of the element in the lattice.</p> <code>None</code>"},{"location":"lattice/element/","title":"Element documentation","text":""},{"location":"lattice/element/#placetmachine.lattice.element.Element","title":"<code>Element(in_parameters=None, index=None, elem_type=None)</code>","text":"<p>         Bases: <code>ABC</code></p> <p>Generic class for element handling in the beamline.</p> <p>Attributes:</p> Name Type Description <code>settings</code> <code>Optional[dict]</code> <p>Dictionary containing the element settings. </p> <code>girder</code> <code>Optional[Girder]</code> <p>The girder reference the <code>Element</code> is placed on. This parameter is only relevant when being the part of the lattice. Upon creation is set to <code>None</code>.</p> <code>type</code> <code>Optional[str]</code> <p>The type of the element.</p> <code>index</code> <code>Optional[int]</code> <p>ID of the element</p> <p>Parameters:</p> Name Type Description Default <code>in_parameters</code> <code>Optional[dict]</code> <p>The dict with input settings.</p> <code>None</code> <code>girder</code> <p>The girder reference the <code>Element</code> is placed on.</p> required <code>index</code> <code>Optional[int]</code> <p>The index of the element in the lattice.</p> <code>None</code>"},{"location":"lattice/element/#placetmachine.lattice.element.Element.cache_data","title":"<code>cache_data()</code>","text":"<p>Cache the cachable parameters.</p> <p>Note: the parameters that can be cached are forcely initiated and assigned to 0.0 when the Element is created.</p>"},{"location":"lattice/element/#placetmachine.lattice.element.Element.to_placet","title":"<code>to_placet()</code>","text":"<p>Convert the element to a Placet format.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string line containing the element description in Placet format.</p>"},{"location":"lattice/element/#placetmachine.lattice.element.Element.use_cached_data","title":"<code>use_cached_data(clear_cache=False)</code>","text":"<p>Use the data stored in cache.</p> <p>Parameters:</p> Name Type Description Default <code>clear_cache</code> <code>bool</code> <p>If True clears the cache after uploading.</p> <code>False</code>"},{"location":"lattice/knob/","title":"knob documentation","text":""},{"location":"lattice/knob/#placetmachine.lattice.knob.Knob","title":"<code>Knob(elements, knob_structure, **extra_params)</code>","text":"<p>A class used to create a Knob.</p> <p>A knob is a certain change in the beamline (elements offsets, strengths change, etc.) that is applied to modify change conditions like beam waist, dispersion or something more complex.</p> <p>So far the elements' types accepted for the knobs creation are <code>Quadrupole</code> and <code>Cavity</code>.</p> <p>The <code>Knob</code> is going to store the references of the <code>Element</code>s provided and use them to  apply the changes. Thus changes to the elements here are going to change the originals.</p> <p>If parameter <code>`step_size'' is provided, the coordinates modifications when using [</code>apply_knob'][placetmachine.lattice.knob.Knob.apply_knob] are adjusted towards the closest  number full of steps.</p> <p>Attributes:</p> Name Type Description <code>elements</code> <code>List[Element]</code> <p>List of the elements that used in this Knob.</p> <code>variables</code> <code>List[dict]</code> <p>A list containing dictionaries that describe the changes that are performed to the elements when <code>Knob</code> is applied. Number of elements in the list should be the same as the number of the elements. It contains the info on the amplitude for each coordinate to change for the given <code>Element</code> as well as the total accumulated changes, mismatches and step sizes. An example of the  dict that describes that <code>Element</code> must be moved vertically by 5.0 micron and horizontaly by -2.0 micron: <pre><code>{\n'y': {\n'amplitude': 5.0,\n'change': 0.0,\n'step_size': 0.5,\n'mismatch': 0.0\n}\n'x': {\n'amplitude': -2.0,\n'change': 0.0\n'step_size': 0.5,\n'mismatch': 0.0\n}\n}\n</code></pre> Both vertical and horizontal movers are anticipated to have a step size of 0.5 micron in this example. Also,  for each coordinate a mismatch and total accumnulated coordinate changes are kept.</p> <code>supported_amplitudes</code> <code>Optional[List[float]]</code> <p>A list of the supported amplitudes. When provided, only the amplitudes from the list are applied. This list contains the amplitudes that an attribute <code>amplitude</code> can take. That means that amplitude given in  <code>Knob.apply()</code> is adjusted so that the sum <code>Knob.amplitude + amplitude</code> eqists in <code>supported_amplitudes</code>. Since, strategies, like <code>min_scale</code> and <code>min_scale_memory</code> have their own amplitude selection, attribute <code>supported_amplitudes</code> has no effect on them.</p> <code>amplitude_mismatch</code> <code>float</code> <p>A mismatch between the amplitude requested and the amplitude applied. By default is <code>0.0</code>. It is modified when the <code>apply()</code> strategy foresees the automatic adjustment of the amplitude. So <code>amplitude_mismatch</code> accomodates this mismatch between multiple <code>apply()</code> calls.</p> <code>name</code> <code>str</code> <p>Name of the Knob.</p> <code>types_of_elements</code> <code>List[str]</code> <p>Types of the elements involved in the Knob.</p> <code>amplitude</code> <code>float</code> <p>The current Knob amplitude.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>List[Element]</code> <p>List of elements to be used for this <code>Knob</code>. Elements provided here must be the elements that are the part of the Beamline.</p> required <code>knobs_structure</code> <p>A list containing info about the elements' amplitudes and step sizes. An example of such a list for a knob containing 2 elements: <pre><code>[{'y':{'amplitude': 2.0, 'step_size': 0.5}}, {'x': {'amplitude': 2.5}, 'y': {'amplitude': -0.5}}]\n</code></pre> Here, the first element has an amplitude <code>2.0</code> for the coordinate <code>y</code>, while the second element requires a combination of <code>x</code> and <code>y</code> changes of <code>2.5</code> and <code>-0.5</code> respectively.</p> required <p>Other Parameters:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the knob. If not provided, defaults to \"\".</p> <code>supported_amplitudes</code> <code>Optional[List[float]]</code> <p>A list of the supported amplitudes.</p>"},{"location":"lattice/knob/#placetmachine.lattice.knob.Knob.__apply_min_scale","title":"<code>__apply_min_scale(amplitude)</code>","text":"<p>Apply the the knob.</p> <p>The offsets are evaluated the following way: 1. The minimum offset is evalued among all the elements. For instance, lets take         the smallest offset amplitude is 1.0 $\\mu$m, step size of 0.5 $\\mu$m, and the knob         amplitude of 0.6. The rounded smallest offsets is goint to be 0.5. 2. We take the smallest rounded offset and evaluate the offsets of the other elements by         scalling the offset amplitudes correspondingly. These offsets are also rounded to          the closest value proportional to the step size.</p> <p>As a result of such adjustemnt - amplitude applied may differ from the amplitude passed.</p> <p>Parameters:</p> Name Type Description Default <code>amplitude</code> <code>float</code> <p>Amplitude of the knob to apply.</p> required"},{"location":"lattice/knob/#placetmachine.lattice.knob.Knob.__apply_min_scale_memory","title":"<code>__apply_min_scale_memory(amplitude, **extra_params)</code>","text":"<p>Apply the the knob.</p> <p>The offsets are evaluated the following way: 1. The minimum offset is evalued among all the elements. For instance, lets take         the smallest offset amplitude is 1.0 $\\mu$m, step size of 0.5 $\\mu$m, and the knob         amplitude of 0.6. The rounded smallest offsets is goint to be 0.5. 2. We take the smallest rounded offset and evaluate the offsets of the other elements by         scalling the offset amplitudes correspondingly. These offsets are also rounded to          the closest value proportional to the step size.</p> <p>As a result of such adjustment - amplitude applied may differ from the amplitude passed.</p> <p>When evaluating the offsets, the mismatch between the current values and values expected by the amplitude are added. Also, the amplitude mismatch (difference between the <code>amplitude</code> provided to the function <code>Knob.amplitude</code>) is taken into accound.</p> <p>Parameters:</p> Name Type Description Default <code>amplitude</code> <code>float</code> <p>Amplitude of the knob to apply.</p> required <p>Other Parameters:</p> Name Type Description <code>use_global_mismatch</code> <code>bool</code> <p>If <code>True</code> (default) coordinates' changes are evaluated to also compensate the possible mismatches caused by other knobs.</p>"},{"location":"lattice/knob/#placetmachine.lattice.knob.Knob.__apply_simple_memory","title":"<code>__apply_simple_memory(amplitude, **extra_params)</code>","text":"<p>Apply the the knob.</p> <p>The offsets to apply are evaluated by rounding the offsets' amplitude taking  into account also the the accumulated mismatch. It also takes into account the  present amplitude mismatch <code>Knob.amplitude_mismatch</code>.</p> <p>If <code>supported_amplitudes</code> is provided, it takes the closest value such that <code>amplitude + Knob.amplitude</code> exist in the <code>knob.supported_amplitudes</code> and  applies it. The difference between the applied and requested amplitudes is  added to <code>amplitude_mismatch</code> attribute.</p> <p>Parameters:</p> Name Type Description Default <code>amplitude</code> <code>float</code> <p>Amplitude of the knob to apply.</p> required <p>Other Parameters:</p> Name Type Description <code>ignore_supported_amplitudes</code> <code>bool</code> <p>If <code>True</code> (default is <code>False</code>) ignores the <code>supported_amplitudes</code> attribute even if present.</p> <code>use_global_mismatch</code> <code>bool</code> <p>If <code>True</code> (default) coordinates' changes are evaluated to also compensate the possible mismatches caused by other knobs.</p>"},{"location":"lattice/knob/#placetmachine.lattice.knob.Knob.__appply_simple","title":"<code>__appply_simple(amplitude, **extra_params)</code>","text":"<p>Apply the the knob.</p> <p>The offsets to apply are evaluated by rounding the offsets' amplitude. Is prone to accumulating the missmatches of the knobs offsets.</p> <p>If <code>supported_amplitudes</code> is provided, it takes the closest value such that <code>amplitude + Knob.amplitude</code> exist in the <code>Knob.supported_amplitudes</code> and  applies it. The difference between the applied and requested amplitudes is  added to <code>amplitude_mismatch</code> attribute.</p> <p>Parameters:</p> Name Type Description Default <code>amplitude</code> <code>float</code> <p>Amplitude of the knob to apply.</p> required <p>Other Parameters:</p> Name Type Description <code>ignore_supported_amplitudes</code> <code>bool</code> <p>If <code>True</code> (default is <code>False</code>) ignores the <code>supported_amplitudes</code> attribute even if present.</p>"},{"location":"lattice/knob/#placetmachine.lattice.knob.Knob.__evaluate_sensitive_coordinate","title":"<code>__evaluate_sensitive_coordinate()</code>","text":"<p>Evaluate the most sensitive coordinate and element by checking the relation between their absolute amplitudes and step sizes. The smaller value is - the more sensitive the element/coordinate is.</p> <p>Returns:</p> Type Description <code>The id of the element and the coordinate of the most sensitive point. If no such found</code> <code>(eg. no step sizes defined) returns `None, None`.</code>"},{"location":"lattice/knob/#placetmachine.lattice.knob.Knob.apply","title":"<code>apply(amplitude, **kwargs)</code>","text":"<p>Apply the knob.</p> <p>Amplitude defines the fraction of the amplitudes of each individual coordinates to add to the  <code>elements</code>s involved in the <code>Knob</code>. If <code>step_size</code> is not defined (default), coordinate change  is applied directly. If <code>step_size</code> is defined, the actual coordinate change may be different from anticipated. This difference may also depend on the <code>strategy</code> used.</p> <p>Parameters:</p> Name Type Description Default <code>amplitude</code> <code>float</code> <p>Amplitude of the knob to apply.</p> required <p>Other Parameters:</p> Name Type Description <code>strategy</code> <code>str</code> <p>Strategy to use for calculations of the offsets when the <code>step_size</code> is defined. Default is <code>None</code>. Possible options are: <pre><code>[None, 'simple', 'simple_memory', 'min_scale', 'min_scale_memory']\n</code></pre> If strategy is <code>None</code> all of the step sizes are ignored.</p> <code>use_global_mismatch</code> <code>bool</code> <p>If <code>True</code> (default) coordinates' changes are evaluated to also compensate the possible mismatches caused by other knobs. Only applicable to the strategies that memorize the mismatches, such as: <pre><code>['simple_memory', 'min_scale_memory']\n</code></pre></p>"},{"location":"lattice/knob/#placetmachine.lattice.knob.Knob.cache_state","title":"<code>cache_state()</code>","text":"<p>Save the current knobs' state into the cache.</p> <p>It saves the changes applied by the knob so it could be restored later. Attributes to be cached: <pre><code>[`amplitude`, `amplitude_mismatch`, `changes`, `mismatch`]\n</code></pre></p>"},{"location":"lattice/knob/#placetmachine.lattice.knob.Knob.reset","title":"<code>reset()</code>","text":"<p>Reset the knob's data.</p> <p>It resets the knob to 0.0 amplitude. That means the elements' offsets changes done  by the knob are removed. Consequently resets the following attributes: <code>amplitude</code>, <code>mismatch</code>, and <code>changes</code>.</p>"},{"location":"lattice/knob/#placetmachine.lattice.knob.Knob.to_dataframe","title":"<code>to_dataframe()</code>","text":"<p>Return the DataFrame with the Knob data.</p> <p>The data included in the DataFrame is: <pre><code>['name', 'type', 'girder', 's']\n</code></pre> which is a name, type, girder id, and location of the element belonging to the girder. Plus the coordinate amplitude, current value in the beamline, coordinate change performed by the knob, and the mismatch when there is a finit step size: <pre><code>['y_amplitude', 'y_current']\n</code></pre> Typically, the properties, like <code>girder</code> or <code>s</code> are acquired during the <code>Beamline</code> creation. When the knob is created on the isolated element, these properties are set to <code>None</code>.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Knob data summary</p>"},{"location":"lattice/knob/#placetmachine.lattice.knob.Knob.upload_state_from_cache","title":"<code>upload_state_from_cache(clear_cache=False)</code>","text":"<p>Upload the knob's data from the cache.</p> <p>Attributes to be upload: <pre><code>[`amplitude`, `amplitude_mismatch`, `changes`, `mismatch`]\n</code></pre> As these values are uploaded - elements' offsets are adjusted correspondingly.</p> <p>Parameters:</p> Name Type Description Default <code>clear_cache</code> <code>bool</code> <p>If <code>True</code> clears the cached data.</p> <code>False</code>"},{"location":"lattice/lattice/","title":"Beamline documentation","text":""},{"location":"lattice/lattice/#placetmachine.lattice.lattice.Beamline","title":"<code>Beamline(name)</code>","text":"<p>A class used to store the beamline lattice.</p> <p>Fully compatible with Placet and can be imported from Placet lattice.</p> <p>The element types it supports: <pre><code>[\"Bpm\", \"Cavity\", \"Quadrupole\", \"Drift\", \"Dipole\", \"Sbend\", \"Multipole\"]\n</code></pre></p> <p>The class <code>Beamline</code> is iterative and elements in the lattice in the beamline can be accessed as in the normal <code>list</code>.</p> <p>Parsers: There are 2 parsers in the <code>Beamline</code> that allow to parse the Placet lattice: <pre><code>[\"default\", \"advanced\"]\n</code></pre></p> <ul> <li> <p>The <code>\"default\"</code> expects the lattice to be well structured with no variables or expressions.</p> </li> <li> <p>The <code>\"advanced\"</code> can parse the variables, expressions and keep the variables in memory.         See AdvancedParser.</p> </li> </ul> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the beamline.</p> <code>lattice</code> <code>List[Element]</code> <p>The list of the elements forming the beamline.</p> <code>attached_knobs</code> <code>List[Knob]</code> <p>The list of the knobs references that are associated with the <code>Beamline</code></p> <code>girders</code> <code>List[Girder]</code> <p>The list of the girders references that are the parts of the <code>Beamline</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the beamline.</p> required"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.Beamline.append","title":"<code>append(element, **extra_params)</code>","text":"<p>Append a given element at the end of the lattice.</p> <p>By default, places the element on the same girder as previous one.  If the previous element is not on the girder or this is the first element,  the element is not placed on girder.</p> <p><code>append()</code> works by duplicating a given element and then appending it.  Thus, the original and the appended element do not share the same reference.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>Element</code> <p>Element to append at the end of the sequence.</p> required <p>Other Parameters:</p> Name Type Description <code>new_girder</code> <code>bool</code> <p>If <code>True</code> (default is <code>False</code>), places the element on a new girder.  Otherwise places it on the same girder last element is placed.</p> <p>If <code>False</code> and there are no elements in the lattice, does not set any girder number  (defaults to <code>None</code>).</p>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.Beamline.attach_knob","title":"<code>attach_knob(knob)</code>","text":"<p>Attach an existing knob to the lattice.</p> <p>The elements included in the knob should exist in the lattice.</p> <p>Parameters:</p> Name Type Description Default <code>knob</code> <code>Knob</code> <p>The knob to attach to the lattice.</p> required"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.Beamline.bpms_numbers_list","title":"<code>bpms_numbers_list()</code>","text":"<p>Get the list of the BPMs indices</p>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.Beamline.cache_lattice_data","title":"<code>cache_lattice_data(elements)</code>","text":"<p>Cache up the data for certain elements.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>List[Element]</code> <p>The list of the elements' references to cache. Each element in the list must be present in the Beamline.</p> required"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.Beamline.cavs_numbers_list","title":"<code>cavs_numbers_list()</code>","text":"<p>Get the list of the Cavities indices</p>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.Beamline.extract","title":"<code>extract(element_types)</code>","text":"<p>Extract certain element type from the lattice.</p> <p>Parameters:</p> Name Type Description Default <code>element_types</code> <code>Union[str, List[str]]</code> <p>The types of elements to extract.</p> required <p>Yields:</p> Type Description <code>Element</code> <p>Element that satisfy the selection criteria.</p>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.Beamline.get_girder","title":"<code>get_girder(girder_index, **extra_params)</code>","text":"<p>Get the element(s) located on the given girder.</p> <p>Parameters:</p> Name Type Description Default <code>girder_id</code> <p>The girder's index in the list of girders list associated with the Beamline</p> required <p>Other Parameters:</p> Name Type Description <code>filter_types</code> <code>Optional[List[str]]</code> <p>The types of elements to extract from the given girder.</p> <p>Yields:</p> Type Description <code>Element</code> <p>Element extracted from the girder.</p>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.Beamline.get_girders_number","title":"<code>get_girders_number()</code>","text":"<p>Get the total number of the girders in the beamline</p> <p>Returns:</p> Type Description <code>int</code> <p>The total number of girders in the lattice.</p>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.Beamline.misalign_articulation_point","title":"<code>misalign_articulation_point(**extra_params)</code>","text":"<p>Offset the articulation point either between 2 girders or at the beamline start/end.</p> <p>The girders and elements on them are misalligned accordingly (wrt the geometry of the girder).</p> <p>There is an option to provide the ids of the girders to the right and to the left of the articulation point. That  require <code>girder_right</code> - <code>girder_left</code> to be equal 1, otherwise an exception will be raised.</p> <p>It is possible to provide only 1 id either of the right or the left one. This also works for the start/end of the beamline.</p> <p>Other Parameters:</p> Name Type Description <code>girder_left</code> <code>Optional[int]</code> <p>The ID of the girder to the left of the articulation point.</p> <code>girder_right</code> <code>Optional[int]</code> <p>The ID of the girder to the right of the articulation point.</p> <code>x</code> <code>float</code> <p>The horizontal offset in micrometers. Default is <code>0.0</code>.</p> <code>y</code> <code>float</code> <p>The vertical offset in micrometers. Default is <code>0.0</code>.</p> <code>apply_angles</code> <code>bool</code> <p>If <code>True</code> (default) applies transverse offsets and angles. Otherwise, only the offsets are applied.</p> <code>filter_types</code> <code>Optional[List[str]]</code> <p>The types of elements to apply the misalignments to. By default, the misalignments are applied to all the elements on the girder.</p>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.Beamline.misalign_element","title":"<code>misalign_element(**extra_params)</code>","text":"<p>Apply the geometrical misalignments to the element given by the element_index.</p> <p>Other Parameters:</p> Name Type Description <code>element_index</code> <code>int</code> <p>The id of the element in the lattice. Required</p> <code>x</code> <code>float</code> <p>The horizontal offset in micrometers. Default is <code>0.0</code>.</p> <code>xp</code> <code>float</code> <p>The horizontal angle in micrometers/m. Default is <code>0.0</code>.</p> <code>y</code> <code>float</code> <p>The vertical offset in micrometers. Default is <code>0.0</code>.</p> <code>yp</code> <code>float</code> <p>The vertical angle in micrometers/m. Default is <code>0.0</code>.</p> <code>roll</code> <code>float</code> <p>The roll angle in microrad. Default is <code>0.0</code>.</p>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.Beamline.misalign_elements","title":"<code>misalign_elements(**extra_params)</code>","text":"<p>Apply the geometrical misalignments to several elements</p> <p>Other Parameters:</p> Name Type Description <code>offsets_data</code> <code>dict</code> <p>[Required] The dictionary with the elements offsets  in the following format: <pre><code>{\n'element_id1': {\n'x': ..\n'y': ..\n..\n}\n'element_id2': {\n..\n}\n..\n}\n</code></pre></p>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.Beamline.misalign_girder","title":"<code>misalign_girder(**extra_params)</code>","text":"<p>Offset the girder transversaly together with the elements on it.</p> <p>All the elements on the girder are equally misaligned.</p> <p>Other Parameters:</p> Name Type Description <code>girder</code> <code>int</code> <p>The girder ID.</p> <code>filter_types</code> <code>Optional[List(str)]</code> <p>The types of elements to apply the misalignments to. By default, the misalignments are applied to all the elements on the girder.</p> <code>x</code> <code>float</code> <p>The horizontal offset in micrometers.</p> <code>y</code> <code>float</code> <p>The vertical offset in micrometers.</p>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.Beamline.misalign_girder_general","title":"<code>misalign_girder_general(**extra_params)</code>","text":"<p>Misalign the girder by means of moving its end points.</p> <p>Other Parameters:</p> Name Type Description <code>girder</code> <code>int</code> <p>The id of the girder. Required</p> <code>x_right</code> <code>float</code> <p>The horizontal offset in micrometers of right end-point. Default is <code>0.0</code>.</p> <code>y_right</code> <code>float</code> <p>The vertical offset in micrometers of the right end-point. Default is <code>0.0</code>.</p> <code>x_left</code> <code>float</code> <p>The horizontal offset in micrometers of left end-point. Default is <code>0.0</code>.</p> <code>y_left</code> <code>float</code> <p>The vertical offset in micrometers of the left end-point. Default is <code>0.0</code>.</p> <code>apply_angles</code> <code>bool</code> <p>If <code>True</code> (default) applies transverse offsets and angles. Otherwise, only the offsets are applied.</p> <code>filter_types</code> <code>Optional[List[str]]</code> <p>The types of elements to apply the misalignments to. By default, the misalignments are applied to all the elements on the girder.</p>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.Beamline.misalign_girders","title":"<code>misalign_girders(**extra_params)</code>","text":"<p>Misalign the girders according to the dictionary.</p> <p>Essentially, it is <code>Beamline.misalign_girder</code> function extended on many girders. That means the input data should have the same structure as the one passed to <code>Beamline.misalign_girder</code>.</p> <p>Maybe, instead Beamline.misalign_girder() it will be replaced with Beamline.misalign_girder_general().</p> <p>Other Parameters:</p> Name Type Description <code>offsets_data</code> <code>dict</code> <p>The dictionary with the girders offsets in the following format: <pre><code>{\n'girder_id1': {\n'x': ..\n'y': ..\n..\n}\n'girder_id2':{\n..\n}\n..\n}\n</code></pre></p> <code>filter_types</code> <code>Optional[List[str]]</code> <p>The types of elements to apply the misalignments to. By default, the misalignments are applied to all the elements on the girder.</p>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.Beamline.quad_numbers_list","title":"<code>quad_numbers_list()</code>","text":"<p>Get the list of the Quadrupoles indices</p>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.Beamline.read_misalignments","title":"<code>read_misalignments(filename, **extra_params)</code>","text":"<p>Read the misalignments from the file.</p> <p>The structure of the file should correspond to the lattice in the memory. Otherwise Placet is going to produce errors.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Name of the file with the misalignments.</p> required <p>Other Parameters:</p> Name Type Description <code>cav_bpm</code> <code>bool</code> <p>Check Placet manual.</p> <code>cav_grad_phas</code> <code>bool</code> <p>Check Placet manual.</p>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.Beamline.read_placet_lattice","title":"<code>read_placet_lattice(filename, **extra_params)</code>","text":"<p>Read the lattice from the Placet lattice file.</p> <p>Evaluates the longitudinal coordinates while parsing the lattice. The coordinate <code>s</code> corresponds  to the element exit.</p> <p>The girders parsed in the process are named based on their ID.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Name of the file with the lattice.</p> required <p>Other Parameters:</p> Name Type Description <code>debug_mode</code> <code>bool</code> <p>If True (default is <code>False</code>), prints all the information it reads and processes.</p> <code>parser</code> <code>str</code> <p>Type of parser to be used. The available optics are <code>\"default\"</code> (default one) and <code>\"advanced\"</code>.</p> <code>parser_variables</code> <code>{}</code> <p>The dict with the variables for the 'advanced parser'.</p>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.Beamline.realign_elements","title":"<code>realign_elements(specific_parameters=None)</code>","text":"<p>Perfectly realign all the elements <code>Beamline.lattice</code> by settings one or all of the the following parameters to zero: <pre><code>['x', 'xp', 'y', 'yp', 'roll', 'tilt']\n</code></pre> If there are knobs that are constructed on the setting to be reset -&gt; knobs are reset as well.</p> <p>Parameters:</p> Name Type Description Default <code>specific_parameters</code> <code>Optional[Union[str, List[str]]]</code> <p>One or several parameters from <code>['x', 'xp', 'y', 'yp', 'roll', 'tilt']</code> to reset. The unspecified parameters are not going to be change.</p> <p>If not specified - all the parameters  in <code>['x', 'xp', 'y', 'yp', 'roll', 'tilt']</code> are reset.</p> <code>None</code>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.Beamline.save_misalignments","title":"<code>save_misalignments(filename, **extra_params)</code>","text":"<p>Write the misalignments to a file.</p> <p>The structure of the file is the same to what is produced with <code>Placet.SaveAllPositions</code>.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Name of the file with the misalignment.</p> required <p>Other Parameters:</p> Name Type Description <code>cav_bpm</code> <code>bool</code> <p>Check Placet manual.</p> <code>cav_grad_phas</code> <code>bool</code> <p>Check Placet manual.</p>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.Beamline.to_placet","title":"<code>to_placet(filename=None)</code>","text":"<p>Write the lattice in Placet readable format.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Optional[str]</code> <p>The name of the file to write the Placet lattice to.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The string with the lattice in Placet readable format.</p>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.Beamline.upload_from_cache","title":"<code>upload_from_cache(elements, clear_cache=False)</code>","text":"<p>Restore the cached data for certain elements.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>List[Element]</code> <p>The list of the elements' references to restore the cache values. Each element in the list must be present in the <code>Beamline</code>.</p> required <code>clear_cache</code> <code>bool</code> <p>If <code>True</code>, clears the cached data.</p> <code>False</code>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.AdvancedParser","title":"<code>AdvancedParser(**variables_list)</code>","text":"<p>A class to do the advances parsing of the Placet lattice.</p> <p>Can perform the following measures:</p> <ul> <li> <p>Read and remember values that are set.</p> <p><code>% set tmp 5</code></p> </li> <li> <p>Put the value instead of the variable.</p> <ol> <li><code>% .. -strength expr [0.5*$e0] ..</code> -&gt; <code>% .. -strength expr [0.5*190.0] ..</code></li> <li><code>% .. -e0 $e_initial ..</code> -&gt; <code>.. -e0 190.0 ..</code></li> </ol> </li> <li> <p>Evaluate the values inside of the <code>expr</code> call.</p> <p><code>% .. -strength expr [0.5*190.0] ..</code> -&gt; <code>% .. -strength 95.0 ..</code></p> </li> <li> <p>Remove the comments part from the line.</p> <p><code>% .. -strength 95.0 # text..</code> -&gt; <code>% .. -strength 95.0</code></p> </li> </ul> <p>Attributes:</p> Name Type Description <code>variables</code> <code>dict</code> <p>Contains the values associated with the variables.</p> <p>Can be declared upon <code>AdvanceParser</code> instance initiation. It also gets automatically extended in the parsing process.</p> <p>Accepts any keyword arguments in <code>variables_list</code>. These values are going to be kept in <code>variables</code> attribute.</p> <p>Can be used to globally modify certain parameters in the beamline, eg. energy (<code>e0</code>).</p>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.AdvancedParser.evaluate_expression","title":"<code>evaluate_expression(match)</code>","text":"<p>Evaluate the expression from inside of a Tcl form <code>expr [..]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>match</code> <code>str</code> <p>An expression to evaluate.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Evaluated value.</p>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.AdvancedParser.parse","title":"<code>parse(line)</code>","text":"<p>Parse the line. Returns the line after applied transformations.</p> <p>Automatically performs the following:</p> <ul> <li> <p>Read and remember values that are set.</p> <p><code>% set tmp 5</code></p> </li> <li> <p>Put the value instead of the variable.</p> <ol> <li><code>% .. -strength expr [0.5*$e0] ..</code> -&gt; <code>% .. -strength expr [0.5*190.0] ..</code></li> <li><code>% .. -e0 $e_initial ..</code> -&gt; <code>.. -e0 190.0 ..</code></li> </ol> </li> <li> <p>Evaluate the values inside of the <code>expr</code> call.</p> <p><code>% .. -strength expr [0.5*190.0] ..</code> -&gt; <code>% .. -strength 95.0 ..</code></p> </li> <li> <p>Remove the comments part from the line.</p> <p><code>% .. -strength 95.0 # text..</code> -&gt; <code>% .. -strength 95.0</code></p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>The string line to parse.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The parsed line.</p>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.AdvancedParser.replace_variables","title":"<code>replace_variables(var)</code>","text":"<p>Replace the input variable by the corresponding value stored in the  memory (<code>variables</code> attribute).</p> <p>If variable does not exist, sets it to <code>'0'</code>.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>str</code> <p>The variable to transform.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The value corresponding to the variable.</p>"},{"location":"lattice/lattice/#placetmachine.lattice.lattice.parse_line","title":"<code>parse_line(data, index=None)</code>","text":"<p>Parse the line of the file with Placet elements.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The line from the PLACET file.</p> required <code>index</code> <code>Optional[int]</code> <p>The current element's id.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple(Optional[str], Optional[Element])</code> <p>The first value is either a value from <code>Beamline._supported_elements</code>, <code>\"Girder\"</code> or <code>None</code>.  <code>None</code> is returned when the line does not contain any element (for example it is a comment, set command, etc.) <code>Element</code> is the object of the corresponding type, if exists. In other case (girder, etc.) returns None.</p>"},{"location":"lattice/multipole/","title":"Multipole documentation","text":""},{"location":"lattice/multipole/#placetmachine.lattice.multipole.Multipole","title":"<code>Multipole(in_parameters=None, index=None)</code>","text":"<p>         Bases: <code>Element</code></p> <p>A class used to store the Multipole information.</p> <p>Attributes:</p> Name Type Description <code>settings</code> <code>dict</code> <p>Dictionary containing the element settings.</p> <code>girder</code> <code>Optional[Girder]</code> <p>The girder reference the <code>Element</code> is placed on. This parameter is only relevant when being the part of the lattice. Upon creation is set to <code>None</code>.</p> <code>type</code> <code>str</code> <p>The type of the element. It is set to \"Multipole\".</p> <p>The list of acceptable settings: <pre><code>[\"name\", \"s\", \"x\", \"y\", \"xp\", \"yp\", \"roll\", \"length\", \"synrad\", \"six_dim\", \n\"thin_lens\", \"e0\", \"aperture_x\", \"aperture_y\", \"aperture_losses\", \n\"aperture_shape\", \"strength\", \"type\", \"steps\", \"tilt\", \"tclcall_entrance\", \n\"tclcall_exit\", \"short_range_wake\"]\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>in_parameters</code> <code>Optional[dict]</code> <p>The dict with input settings.</p> <code>None</code> <code>girder</code> <p>The number of the girder element is placed.</p> required <code>index</code> <code>Optional[int]</code> <p>The index of the element in the lattice.</p> <code>None</code>"},{"location":"lattice/quadrupole/","title":"Quadrupole documentation","text":""},{"location":"lattice/quadrupole/#placetmachine.lattice.quadrupole.Quadrupole","title":"<code>Quadrupole(in_parameters=None, index=None)</code>","text":"<p>         Bases: <code>Element</code></p> <p>A class used to store the quadrupole information.</p> <p>Attributes:</p> Name Type Description <code>settings</code> <code>dict</code> <p>Dictionary containing the element settings.</p> <code>girder</code> <code>Optional[Girder]</code> <p>The girder reference the <code>Element</code> is placed on. This parameter is only relevant when being the part of the lattice. Upon creation is set to <code>None</code>.</p> <code>type</code> <code>str</code> <p>The type of the element. It is set to \"Quadrupole\".</p> <p>The list of acceptable settings: <pre><code>[\"name\", \"comment\", \"s\", \"x\", \"y\", \"xp\", \"yp\", \"roll\", \"tilt\", \"tilt_deg\", \n\"length\", \"synrad\", \"six_dim\", \"thin_lens\", \"e0\", \"aperture_x\", \"aperture_y\", \n\"aperture_losses\", \"aperture_shape\", \"tclcall_entrance\", \"tclcall_exit\", \n\"short_range_wake\", \"strength\", \"Kn\", \"type\", \"hcorrector\", \n\"hcorrector_step_size\", \"vcorrector\", \"vcorrector_step_size\"]\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>in_parameters</code> <code>Optional[dict]</code> <p>The dict with input settings.</p> <code>None</code> <code>girder</code> <p>The number of the girder element is placed.</p> required <code>index</code> <code>Optional[int]</code> <p>The index of the element in the lattice.</p> <code>None</code>"},{"location":"lattice/sbend/","title":"Sbend documentation","text":""},{"location":"lattice/sbend/#placetmachine.lattice.sbend.Sbend","title":"<code>Sbend(in_parameters=None, index=None)</code>","text":"<p>         Bases: <code>Element</code></p> <p>A class used to store the sbend information</p> <p>Attributes:</p> Name Type Description <code>settings</code> <code>dict</code> <p>Dictionary containing the element settings.</p> <code>girder</code> <code>Optional[Girder]</code> <p>The girder reference the <code>Element</code> is placed on. This parameter is only relevant when being the part of the lattice. Upon creation is set to <code>None</code>.</p> <code>type</code> <code>str</code> <p>The type of the element. It is set to \"Sbend\".</p> <p>The list of acceptable settings: <pre><code>[\"name\", \"s\", \"x\", \"y\", \"xp\", \"yp\", \"roll\", \"length\", \"synrad\", \"six_dim\", \n\"thin_lens\", \"e0\", \"aperture_x\", \"aperture_y\", \"aperture_losses\", \n\"aperture_shape\", \"angle\", \"E1\", \"E2\", \"K\", \"K2\", \"tilt\", \"tclcall_entrance\", \n\"tclcall_exit\", \"short_range_wake\"]\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>in_parameters</code> <code>Optional[dict]</code> <p>The dict with input settings.</p> <code>None</code> <code>girder</code> <p>The number of the girder element is placed.</p> required <code>index</code> <code>Optional[int]</code> <p>The index of the element in the lattice.</p> <code>None</code>"},{"location":"placet/communicator/","title":"Placet documentation","text":""},{"location":"placet/communicator/#placetmachine.placet.communicator.Communicator","title":"<code>Communicator(process_name, **kwargs)</code>","text":"<p>         Bases: <code>ABC</code></p> <p>A class used to interact with the process spawned with <code>Pexpect</code>.</p> <p>Attributes:</p> Name Type Description <code>process</code> <code>pexpect.spawn</code> <p>The child process spawned with pexpect.</p> <code>debug_mode</code> <code>bool</code> <p>If True, running in debug mode.</p> <p>Parameters:</p> Name Type Description Default <code>process_name</code> <code>str</code> <p>Name of the child process</p> required <p>Other Parameters:</p> Name Type Description <code>debug_mode</code> <code>bool</code> <p>If <code>True</code> (default is <code>False</code>), runs <code>Communicator</code> in debug mode.</p> <code>save_logs</code> <code>bool</code> <p>If <code>True</code> (default is <code>True</code>) , invoking <code>save_debug_info()</code>.</p> <code>send_delay</code> <code>float</code> <p>The time delay before each data transfer to a child process (sometimes needed for stability). Default is <code>Communicator._BUFFER_MAXSIZE</code>.</p>"},{"location":"placet/communicator/#placetmachine.placet.communicator.Communicator.__save_logs","title":"<code>__save_logs()</code>","text":"<p>Open the files to store the log data of a child process</p> <p>By default, the names are \"log_send.txt\" for logfile_send and \"log_read.txt\" for logfile_read.</p>"},{"location":"placet/communicator/#placetmachine.placet.communicator.Communicator.__terminate","title":"<code>__terminate()</code>","text":"<p>Terminate the child process.</p>"},{"location":"placet/communicator/#placetmachine.placet.communicator.Communicator.add_send_delay","title":"<code>add_send_delay(time=_DELAY_BEFORE_SEND)</code>","text":"<p>Add the time delay before each data transfer.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The time delay.</p> <code>_DELAY_BEFORE_SEND</code>"},{"location":"placet/communicator/#placetmachine.placet.communicator.Communicator.close","title":"<code>close()</code>","text":"<p>Close all the associated threads running.</p>"},{"location":"placet/communicator/#placetmachine.placet.communicator.Communicator.flush","title":"<code>flush()</code>","text":"<p>Flush the child process buffer</p>"},{"location":"placet/communicator/#placetmachine.placet.communicator.Communicator.readline","title":"<code>readline()</code>  <code>abstractmethod</code>","text":"<p>Read the line from the child process.</p> <p>Returns:</p> Type Description <code>str</code> <p>The line of the data received from the child process.</p>"},{"location":"placet/communicator/#placetmachine.placet.communicator.Communicator.readlines","title":"<code>readlines(N_lines, timeout=_BASE_TIMEOUT)</code>","text":"<p>Read several lines from the child process.</p> <p>Parameters:</p> Name Type Description Default <code>N_lines</code> <code>int</code> <p>Number of lines to read.</p> required <code>timeout</code> <code>float</code> <p>Timeout of the reader before raising the exception. [30.11.2022] - No effect anymore. The parameter is kept for compatibility.</p> <code>_BASE_TIMEOUT</code> <p>Returns:</p> Type Description <code>list</code> <p>The list of the lines received from the child process.</p>"},{"location":"placet/communicator/#placetmachine.placet.communicator.Communicator.save_debug_info","title":"<code>save_debug_info(filename='debug_data.pkl')</code>","text":"<p>Save the debug info to a files.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Name of the file.</p> <code>'debug_data.pkl'</code>"},{"location":"placet/communicator/#placetmachine.placet.communicator.Communicator.skipline","title":"<code>skipline(timeout=_BASE_TIMEOUT)</code>","text":"<p>Skip the line of the child's process output.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Timeout of the reader before raising the exception. [30.11.2022] - No effect anymore. The parameter is kept for compatibility.</p> <code>_BASE_TIMEOUT</code>"},{"location":"placet/communicator/#placetmachine.placet.communicator.Communicator.writeline","title":"<code>writeline(command, skipline=True, timeout=_BASE_TIMEOUT, **kwargs)</code>","text":"<p>Send the line to a child process.</p> <p>There is an <code>expect</code> call to search for a prompt defined in <code>Communicator._TERMINAL_SPECIAL_SYMBOL</code> (default value is '% ') before writing to a process - <code>process.write()</code>. Doing so, we make sure that we do not try to write while the process  is still busy with the previous command. We set the default timeout of <code>Communicator._BASE_TIMEOUT</code>.</p> <p>The optional parameters <code>expect_before</code> and <code>expect_after</code> used to specify when to use the expect command in between writing the command. There has to be always 1 <code>expect</code> call after command execution. By default, one <code>expect</code> call is used before writing the command. In certain situations, one would want to do the <code>expect</code> call after the command is written. The parameter <code>__expect_block</code> controls the use of <code>expect</code> commands - making sure, only 1 expect command is  executed in between 2 commands.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Command to execute</p> required <code>skipline</code> <code>bool</code> <p>If True, reads the command that was sent to a child process from child's process output This flag depends on the default running mode of pexpect. By default, it outputs to stdout what was just send to stdin</p> <code>True</code> <code>timeout</code> <code>float</code> <p>Timeout of the reader before raising the exception. [30.11.2022] - No effect anymore. The parameter is kept for compatibility.</p> <code>_BASE_TIMEOUT</code> <p>Other Parameters:</p> Name Type Description <code>expect_before</code> <code>bool</code> <p>If <code>True</code> (default is <code>True</code>), <code>expect</code> is invoked before writing the command.</p> <code>expect_after</code> <code>bool</code> <p>If <code>True</code> (default is <code>False</code>), <code>expect</code> is invoked after writing the command.</p> <code>no_expect</code> <code>bool</code> <p>If <code>True</code> (default is <code>False</code>), no <code>expect</code> is invoked, ignoring <code>__expect_block</code></p> <p>Returns:</p> Type Description <code>str</code> <p>The command that was sent to a child process</p>"},{"location":"placet/placetwrap/","title":"Placet documentation","text":""},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet","title":"<code>Placet(**Placetpy_params)</code>","text":"<p>         Bases: <code>Placetpy</code></p> <p>A class used to wrap the Placet commands in a usable format within Python.</p> <p>Further extends <code>Placetpy</code> by wrapping the commands.</p> <p>Other Parameters:</p> Name Type Description <code>show_intro</code> <code>bool</code> <p>If <code>True</code> (defauls is <code>True</code>), prints the welcome message of Placet at the start.</p> <code>debug_mode</code> <code>bool</code> <p>If <code>True</code> (default is <code>False</code>), runs <code>Placet</code> in debug mode.</p> <code>save_logs</code> <code>bool</code> <p>If <code>True</code> (default is <code>True</code>) , invoking <code>save_debug_info()</code>.</p> <code>send_delay</code> <code>float</code> <p>The time delay before each data transfer to a child process (sometimes needed for stability). Default is <code>Placet._BUFFER_MAXSIZE</code>.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.BeamAddOffset","title":"<code>BeamAddOffset(**command_details)</code>","text":"<p>Run the <code>BeamAddOffset</code> command in Placet TCL.</p> <p>Modifies the beam by either applying the offsets, angles, or rotating it.</p> <p>Parameters that are not specified are not modified.</p> <p>Other Parameters:</p> Name Type Description <code>beam</code> <code>str</code> <p>The name of the beam to modify.  There is no check to verify that such a beam exists.</p> <code>x</code> <code>float</code> <p>Horizontal offset in micrometers.</p> <code>y</code> <code>float</code> <p>Vertical offset in micrometers.</p> <code>angle_x</code> <code>float</code> <p>Horizontal angle in microradians.</p> <code>angle_y</code> <code>float</code> <p>Vertical angle in microradians.</p> <code>rotate</code> <code>float</code> <p>Roll angle in radians. It is added after the offsets.</p> <code>start</code> <code>int</code> <p>First particle to offset.</p> <code>end</code> <code>int</code> <p>Last particle to offset.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.BeamDump","title":"<code>BeamDump(**command_details)</code>","text":"<p>Run the 'BeamDump' command in Placet.</p> <p>Saves the particle beam coordinates.</p> <p>Other Parameters:</p> Name Type Description <code>file</code> <code>str</code> <p>Name of the file from where to write the particles.</p> <code>beam</code> <code>str</code> <p>Name of the beam into which to read the particles.</p> <code>xaxis</code> <code>int</code> <p>If not zero remove mean horizontal angle and offset.</p> <code>yaxis</code> <code>int</code> <p>If not zero remove mean vertical angle and offset.</p> <code>binary</code> <code>int</code> <p>If not zero write in binary format.</p> <code>binary_stream</code> <code>str</code> <p>Name of the file where to write particles to as a binary stream.</p> <code>losses</code> <code>int</code> <p>If not zero write also the lost particles into the file.</p> <code>seed</code> <code>int</code> <p>Seed to be used for transforming slices to rays.</p> <code>type</code> <code>int</code> <p>If 1 the particles distribution in energy and z comes from continuous slices.</p> <code>rotate_x</code> <code>float</code> <p>rotate the bunch in the s x plane [rad].</p> <code>rotate_y</code> <code>float</code> <p>rotate the bunch in the s y plane [rad].</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.BeamRead","title":"<code>BeamRead(**command_details)</code>","text":"<p>Run 'BeamRead' command in Placet.</p> <p>Reads the beam from a file. Before calling 'BeamRead', the beam has to be created</p> <p>Other Parameters:</p> Name Type Description <code>file</code> <code>str</code> <p>The name of the file to read.</p> <code>binary</code> <code>int</code> <p>If not zero read in binary format.</p> <code>binary_stream</code> <code>str</code> <p>Name of the file where to read particles from as a binary stream.</p> <code>beam</code> <code>str</code> <p>Name of the beam to be read.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.BeamSaveAll","title":"<code>BeamSaveAll(**command_details)</code>","text":"<p>Run the 'BeamSaveAll' command in Placet.</p> <p>It saves the macroparticle beam to a file.</p> <p>Other Parameters:</p> Name Type Description <code>file</code> <code>str</code> <p>File containing beam to be saved.</p> <code>beam</code> <code>str</code> <p>Name of the beam to be saved.</p> <code>header</code> <code>int</code> <p>If set to 1 write a header into the file.</p> <code>axis</code> <code>int</code> <p>If set to 1 subtract the mean position and offset.</p> <code>binary</code> <code>int</code> <p>If set to 1 binary data is saved.</p> <code>bunches</code> <code>int</code> <p>If set to 1 each bunch is saved in a different file.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p> <p>The output file consists of:</p> <ol> <li>s long position along [um]</li> <li>weight</li> <li>energy [GeV]</li> <li>x [um]</li> <li>x' [um/m]</li> <li>y [um]</li> <li>y' [um/m]</li> <li>sigma_xx</li> <li>sigma_xx'</li> <li>sigma_x'x'</li> <li>sigma_yy</li> <li>sigma_yy'</li> <li>sigma_y'y'</li> <li>sigma_xy (always 0)</li> <li>0</li> <li>0</li> <li>0</li> </ol>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.BeamSetToOffset","title":"<code>BeamSetToOffset(**command_details)</code>","text":"<p>Run 'BeamSetToOffset' command in Placet.</p> <p>Offsets the beam according to the given settings.</p> <p>Other Parameters:</p> Name Type Description <code>beam</code> <code>str</code> <p>The name of the beam.</p> <code>x</code> <code>float</code> <p>x in microns.</p> <code>y</code> <code>float</code> <p>y in microns.</p> <code>angle_x</code> <code>float</code> <p>Horizontal angle in microrads.</p> <code>angle_y</code> <code>float</code> <p>Vertical angle in microrads.</p> <code>start</code> <code>int</code> <p>First element to misalign the  beam at.</p> <code>end</code> <code>int</code> <p>Last element to misalign the beam at.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.BeamlineNew","title":"<code>BeamlineNew(**command_details)</code>","text":"<p>Run 'BeamlineNew' command in Placet.</p> <p>It is required to be called before starting declaring the beamline. All the elements declared afterwards are going to be included in the  new beamline.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.BeamlineSet","title":"<code>BeamlineSet(**command_details)</code>","text":"<p>Run     'BeamlineSet' command in Placet TCL.</p> <p>Fixes the beamline. This command is used to do some initial calculations. It must be called once but only once for a given beamline in a run.</p> <p>Other Parameters:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the beamline to create. Required</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.BpmNumberList","title":"<code>BpmNumberList(**command_details)</code>","text":"<p>Run the 'BpmNumberList' command in Placet.</p> <p>It returns the list BPMs IDs.</p> <p>The following chain is executed: <pre><code>% set tmp [BpmNumberList]\n% puts $tmp\n</code></pre> An alternative is the use of <code>Beamline</code>.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>The list with the BPMs IDs.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.BpmReadings","title":"<code>BpmReadings(**command_details)</code>","text":"<p>Run the 'BpmReadings' command in Placet.</p> <p>Reads the reading on the BPMs available in the beamlimne. Before doing so, Placet must run any kind of tracking.</p> <p>Other Parameters:</p> Name Type Description <code>file</code> <code>str</code> <p>The name of the file to store the bpm readings.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.BpmRealign","title":"<code>BpmRealign(**command_details)</code>","text":"<p>Run the 'BpmRealign' command in Placet TCL.</p> <p>Realigns the BPMs tranversaly such that their centers are aligned with the current beam orbit.</p> <p>Other Parameters:</p> Name Type Description <code>error_x</code> <code>float</code> <p>Error in horizontal plane.</p> <code>error_y</code> <code>float</code> <p>Error in vertical plane.</p> <code>bunch</code> <code>int</code> <p>Which bunch to use as a reference (-1: mean of all bunches).</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.CavityGetPhaseList","title":"<code>CavityGetPhaseList(**command_details)</code>","text":"<p>Run the 'CavityGetPhaseList' command in Placet.</p> <p>It returns the list with the cavities' phases.</p> <p>The following chain is executed: <pre><code>% set tmp [CavityGetPhaseList]\n% puts $tmp\n</code></pre></p> <p>A better alternative is the use of <code>Beamline</code>.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p> <p>Returns:</p> Type Description <code>List[float]</code> <p>The list of the cavities phases.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.CavityNumberList","title":"<code>CavityNumberList(**command_details)</code>","text":"<p>Run the 'CavityNumberList' command in Placet.</p> <p>It returns the list cavities IDs.</p> <p>The following chain is executed: <pre><code>% set tmp [CavityNumberList]\n% puts $tmp\n</code></pre> An alternative is the use of <code>Beamline</code>.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>The list with the cavities IDs.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.CavitySetGradientList","title":"<code>CavitySetGradientList(values_list, **command_details)</code>","text":"<p>Run the 'CavitySetGradientList' command in Placet.</p> <p>It sets the gradients of the cavities according to the input data. The length of the list must correspond to the number of cavities, otherwise Placet throws an error</p> <p>A better alternative is the use of <code>Beamline</code>.</p> <p>Parameters:</p> Name Type Description Default <code>values_list</code> <p>The list with cavities gradients</p> required <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.CavitySetPhaseList","title":"<code>CavitySetPhaseList(values_list, **command_details)</code>","text":"<p>Run the 'CavitySetPhaseList' command in Placet.</p> <p>It sets the phases of the cavities according to the input data. The length of the list must correspond to the number of cavities, otherwise Placet would throw an error</p> <p>A better alternative is the use of <code>Beamline</code>.</p> <p>Parameters:</p> Name Type Description Default <code>values_list</code> <code>List[float]</code> <p>The list with cavities gradients.</p> required <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.Clic","title":"<code>Clic(**command_details)</code>","text":"<p>Run 'Clic' command in Placet.</p> <p>It sets the beamline misalignment according to the CLIC setup.</p> <p>Other Parameters:</p> Name Type Description <code>start</code> <code>int</code> <p>The ID of the first element to apply the misalignments.</p> <code>end</code> <code>int</code> <p>The ID of the last element to apply the misalignments.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.CollimatorNumberList","title":"<code>CollimatorNumberList(**command_details)</code>","text":"<p>Run the 'CollimatorNumberList' command in Placet.</p> <p>It returns the list collimators IDs.</p> <p>The following chain is executed: <pre><code>% set tmp [CollimatorNumberList]\n% puts $tmp\n</code></pre></p> <p>An alternative is the use of <code>Beamline</code>.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>The list with the colimators IDs.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.DipoleNumberList","title":"<code>DipoleNumberList(**command_details)</code>","text":"<p>Run the 'DipoleNumberList' command in Placet.</p> <p>It returns the list dipoles IDs.</p> <p>The following chain is executed: <pre><code>% set tmp [DipoleNumberList]\n% puts $tmp\n</code></pre></p> <p>An alternative is the use of <code>Beamline</code>.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>The list with the dipoles IDs.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.ElementAddOffset","title":"<code>ElementAddOffset(index, **command_details)</code>","text":"<p>Run 'ElementAddOffset' command in Placet.</p> <p>Adds the given offsets to the current ones of the given element.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <p>The element ID.</p> required <p>Other Parameters:</p> Name Type Description <code>x</code> <code>float</code> <p>Horizontal offset.</p> <code>y</code> <code>float</code> <p>Vertical offset.</p> <code>xp</code> <code>float</code> <p>Horizontal offset in angle [urad].</p> <code>yp</code> <code>float</code> <p>Vertical offset in angle [urad].</p> <code>roll</code> <code>float</code> <p>Roll angle [urad].</p> <code>angle_x</code> <code>float</code> <p>Same as -xp [backward compatibility].</p> <code>angle_y</code> <code>float</code> <p>Same as -yp [backward compatibility].</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.ElementGetAttribute","title":"<code>ElementGetAttribute(element_id, parameter, **command_details)</code>","text":"<p>Run 'ElementGetAttribute' command in Placet.</p> <p>It extracts the value of the element's parameter with the given id.</p> <p>A better alternative is the use of <code>Beamline</code>.</p> <p>Parameters:</p> Name Type Description Default <code>element_id</code> <code>int</code> <p>ID of an element.</p> required <code>parameter</code> <code>str</code> <p>Parameter to extract</p> required <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p> <p>Returns:</p> Type Description <code>float</code> <p>The extracted value.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.ElementSetAttributes","title":"<code>ElementSetAttributes(element_id, **command_details)</code>","text":"<p>Run 'ElementSetAttributes' command in Placet.</p> <p>It sets the given parameters in <code>command_details</code> to the given element.</p> <p>The full list of the possible arguments (depends on the element type) is: <pre><code>['name', 's', 'x', 'y', 'xp', 'yp', 'roll', 'length', 'synrad', 'six_dim', 'thin_lens', 'e0', 'aperture_x', 'aperture_y', 'aperture_losses', 'aperture_shape',\n'strength', 'tilt', 'hcorrector', 'hcorrector_step_size', 'vcorrector', 'vcorrector_step_size', 'angle', 'E1', 'E2', 'K', 'K2', 'resolution', 'reading_x', \n'reading_y', 'scale_x', 'scale_y', 'store_bunches', 'gradient', 'phase', 'type', 'lambda', 'frequency', 'strength_x', 'strength_y', 'steps']\n</code></pre></p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.ElementSetToOffset","title":"<code>ElementSetToOffset(index, **command_details)</code>","text":"<p>Run 'ElementSetToOffset' command in Placet.</p> <p>Sets the given offsets to a given element.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The element ID.</p> required <p>Other Parameters:</p> Name Type Description <code>x</code> <code>float</code> <p>Horizontal offset.</p> <code>y</code> <code>float</code> <p>Vertical offset.</p> <code>xp</code> <code>float</code> <p>Horizontal offset in angle [urad].</p> <code>yp</code> <code>float</code> <p>Vertical offset in angle [urad].</p> <code>roll</code> <code>float</code> <p>Roll angle [urad].</p> <code>angle_x</code> <code>float</code> <p>Same as -xp [backward compatibility].</p> <code>angle_y</code> <code>float</code> <p>Same as -yp [backward compatibility].</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.FirstOrder","title":"<code>FirstOrder(**command_details)</code>","text":"<p>Run \"FirstOrder\" command in Placet.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.GetTransferMatrix","title":"<code>GetTransferMatrix(**command_details)</code>","text":"<p>Run'GetTransferMatrix' command in Placet.</p> <p>Evaluates the transfer matrix between the given elements.</p> <p>The foolowing chain is executed: <pre><code>% set tmp [GetTransferMatrix ..]\n% puts $tmp\n</code></pre></p> <p>Other Parameters:</p> Name Type Description <code>beamline</code> <code>str</code> <p>Name of the beamline to be saved. Required</p> <code>start</code> <code>int</code> <p>Element to start from.</p> <code>end</code> <code>int</code> <p>Element to end to.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p> <p>Returns:</p> Type Description <code>List[float]</code> <p>Resulting transfer matrix.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.InjectorBeam","title":"<code>InjectorBeam(beam_name, **command_details)</code>","text":"<p>Run the 'InjectorBeam' command in Placet.</p> <p>Creates a new macroparticle beam in Placet based on the template of the InjectorBeam.  It is typically used to create any type of beam.</p> <p>The list of parameters is taken from Placet manual.</p> <p>Other Parameters:</p> Name Type Description <code>macroparticles</code> <code>int</code> <p>Number of macroparticles per slice.</p> <code>silent</code> <code>int (?)</code> <p>Suppress output at beam creation.</p> <code>energyspread</code> <code>float</code> <p>Energy spread of initial beam, minus value is linear spread, positive gaussian spread.</p> <code>ecut</code> <code>float</code> <p>Cut of the energy spread of initial beam.</p> <code>energy_distribution</code> <code>float</code> <p>Energy distribution of initial beam.</p> <code>file</code> <code>str</code> <p>Filename for the single bunch parameters.</p> <code>bunches</code> <code>int</code> <p>Number of bunches.</p> <code>chargelist</code> <code>str</code> <p>List of bunch charges (required).</p> <code>slices</code> <code>int</code> <p>Number of slices.</p> <code>e0</code> <code>float</code> <p>Beam energy at entrance.</p> <code>charge</code> <code>float</code> <p>Bunch charge.</p> <code>particles</code> <code>int</code> <p>Number of particles for particle beam.</p> <code>last_wgt</code> <code>float</code> <p>Weight of the last bunch for the emittance.</p> <code>distance</code> <code>float</code> <p>Bunch distance.</p> <code>overlapp</code> <code>float</code> <p>Bunch overlap.</p> <code>phase</code> <code>float</code> <p>Bunch phase.</p> <code>wake_scale_t</code> <code>float</code> <p>Wakefield scaling transverse.</p> <code>wake_scale_l</code> <code>float</code> <p>Wakefield scaling longitudinal.</p> <code>beta_x</code> <code>float</code> <p>Horizontal beta function at entrance (required).</p> <code>alpha_x</code> <code>float</code> <p>Horizontal alpha at entrance (required).</p> <code>emitt_x</code> <code>float</code> <p>Horizontal emittance at entrance (required).</p> <code>beta_y</code> <code>float</code> <p>Vertical beta function at entrance (required).</p> <code>alpha_y</code> <code>float</code> <p>Vertical alpha at entrance (required).</p> <code>emitt_y</code> <code>float</code> <p>Vertical emittance at entrance (required).</p> <code>beamload</code> <code>int</code> <p>Spline containing the longtudinal beam loading.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.InterGirderMove","title":"<code>InterGirderMove(**command_details)</code>","text":"<p>Run the 'InterGirderMove' command in Placet.</p> <p>It sets the alignment properties of the girder endpoints wrt the reference wire and itselves.</p> <p>Other Parameters:</p> Name Type Description <code>scatter_x</code> <code>float</code> <p>Sigma of Gaussian scattering in x view of the intersubsections between girders [micrometers].</p> <code>scatter_y</code> <code>float</code> <p>Sigma of Gaussian scattering in y view of the intersubsections between girders [micrometers].</p> <code>flo_x</code> <code>float</code> <p>Sigma of Gaussian scattering in x view of the girder connection around the intersubsection point [micrometers].</p> <code>flo_y</code> <code>float</code> <p>Sigma of Gaussian scattering in y view of the girder connection around the intersubsection point [micrometers].</p> <code>cav_only</code> <code>int</code> <p>If not zero move only the cavities on the girder.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.MoveGirder","title":"<code>MoveGirder(**command_details)</code>","text":"<p>Run 'MoveGirder' command in Placet.</p> <p>Other Parameters:</p> Name Type Description <code>file</code> <code>str</code> <p>File to read.</p> <code>vertical_only</code> <code>int</code> <p>If not 0 only vertical plane is in the file.</p> <code>binary</code> <code>int</code> <p>If not 0 read as binary file.</p> <code>scale</code> <code>float</code> <p>Scaling factor for the motion.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.MultipoleNumberList","title":"<code>MultipoleNumberList(**command_details)</code>","text":"<p>Run the 'MultipoleNumberList' command in Placet.</p> <p>It returns the list multipoles IDs.</p> <p>The following chain is executed: <pre><code>% set tmp [MultipoleNumberList -orded order]\n% puts $tmp\n</code></pre></p> <p>An alternative is the use of <code>Beamline</code>.</p> <p>Other Parameters:</p> Name Type Description <code>order</code> <code>int</code> <p>Order of the multipoles. Required</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>The list with the multipoles IDs.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.QuadrupoleGetStrength","title":"<code>QuadrupoleGetStrength(quad_number, **command_details)</code>","text":"<p>Run 'QuadrupoleGetStrength' command in Placet.</p> <p>It returns the strength of the quadrupole with the given number.</p> <p>The following chain is executed: <pre><code>% set tmp [QuadrupoleGetStrength quad_number]\n% puts $tmp\n</code></pre></p> <p>A better alternative is the use of <code>Beamline</code>.</p> <p>Parameters:</p> Name Type Description Default <code>quad_number</code> <code>int</code> <p>The quad ID.</p> required <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p> <p>Returns:</p> Type Description <code>float</code> <p>Quadrupole strength.</p> <p>Needs to be verified!</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.QuadrupoleNumberList","title":"<code>QuadrupoleNumberList(**command_details)</code>","text":"<p>Run the 'QuadrupoleNumberList' command in Placet.</p> <p>It returns the list quadrupoles IDs.</p> <p>The following chain is executed: <pre><code>% set tmp [QuadrupoleNumberList]\n% puts $tmp\n</code></pre> An alternative is the use of <code>Beamline</code>.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p> <p>Returns:</p> Type Description <code>List[int]</code> <p>The list with the quadrupoles IDs.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.QuadrupoleSetStrength","title":"<code>QuadrupoleSetStrength(quad_number, value, **command_details)</code>","text":"<p>Run 'QuadrupoleSetStrength' command in Placet.</p> <p>It sets the given strength os the quadrupole of the given number.</p> <p>Parameters:</p> Name Type Description Default <code>quad_number</code> <code>int</code> <p>The quadrupole ID.</p> required <code>value</code> <code>float</code> <p>Quadrupole new strengths.</p> required <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.QuadrupoleSetStrengthList","title":"<code>QuadrupoleSetStrengthList(values_list, **command_details)</code>","text":"<p>Run the 'QuadrupoleSetStrengthList' in Placet.</p> <p>It sets the strengths of the quadrupoles according to the input data. The length of the list must correspond to the number of cavities, otherwise Placet throws an error.</p> <p>A better alternative is the use of <code>Beamline</code>.</p> <p>Parameters:</p> Name Type Description Default <code>values_list</code> <code>List[float]</code> <p>The list with the quadrupoles strengths.</p> required <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.RandomReset","title":"<code>RandomReset(**command_details)</code>","text":"<p>Run the 'RandomReset' command in Placet.</p> <p>Resets the errors seed number in Placet.</p> <p>Other Parameters:</p> Name Type Description <code>seed</code> <code>int</code> <p>The seed number to set.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.ReadAllPositions","title":"<code>ReadAllPositions(**command_details)</code>","text":"<p>Run 'ReadAllPositions' command in Placet.</p> <p>Reads the elements' positions from a file and applies them to a beamline.</p> <p>Other Parameters:</p> Name Type Description <code>file</code> <code>str</code> <p>Filename to read. Required</p> <code>binary</code> <code>int</code> <p>If not 0 read as binary file.</p> <code>nodrift</code> <code>int</code> <p>If not 0 drift positions are not read.</p> <code>nomultipole</code> <code>int</code> <p>If not 0, multipoles are not read.</p> <code>vertical_only</code> <code>int</code> <p>If not 0 only vertical information are read.</p> <code>positions_only</code> <code>int</code> <p>If not 0 only positions are read.</p> <code>cav_bpm</code> <code>int</code> <p>If not 0 positions of structure BPMs are read.</p> <code>cav_grad_phas</code> <code>int</code> <p>If not 0 gradient and phase of structure are read.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.SaveAllPositions","title":"<code>SaveAllPositions(**command_details)</code>","text":"<p>Run 'SaveAllPositions' command in Placet.</p> <p>It saves all the elements positions into a file.</p> <p>Other Parameters:</p> Name Type Description <code>file</code> <code>str</code> <p>Filename to write. Required</p> <code>binary</code> <code>int</code> <p>If not 0 save as binary file.</p> <code>nodrift</code> <code>int</code> <p>If not 0 drift positions will not be saved.</p> <code>vertical_only</code> <code>int</code> <p>If not 0 only vertical information will be saved.</p> <code>positions_only</code> <code>int</code> <p>If not 0 only positions will be saved.</p> <code>cav_bpm</code> <code>int</code> <p>If not 0 positions of structure BPMs will be saved.</p> <code>cav_grad_phas</code> <code>int</code> <p>If not 0 gradient and phase of structure will be saved.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.SetRfGradientSingle","title":"<code>SetRfGradientSingle(beam_name, var1, l)</code>","text":"<p>Run 'SetRFGradientSingle' command in Placet.</p> <p>This function is not documented. Placet sources are not clear either. It is wrapped as it is.</p> <p>Parameters:</p> Name Type Description Default <code>beam_name</code> <code>str</code> <p>Beam name.</p> required <code>var1</code> <code>float</code> <p>No idea.</p> required <code>l</code> <code>float</code> <p>No idea.</p> required"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.SurveyErrorSet","title":"<code>SurveyErrorSet(**command_details)</code>","text":"<p>Run 'SurveyErrorSet' command in Placet.</p> <p>It sets the alignment errors for the beamline. When the command is invoked - it overwrittes the values already in memory. That means if one calls it with <code>cavity_y = 5.0</code> that means that <code>cavity_y</code> property will be overwritten, others will be kept unchanged. So the values not declared are zeros by default.</p> <p>The descriptions taken from the Placet Manual</p> <p>Other Parameters:</p> Name Type Description <code>quadrupole_x</code> <code>float</code> <p>Horizontal quadrupole position error [micro m].</p> <code>quadrupole_y</code> <code>float</code> <p>Vertical quadrupole position error [micro m].</p> <code>quadrupole_xp</code> <code>float</code> <p>Horizontal quadrupole angle error [micro radian].</p> <code>quadrupole_yp</code> <code>float</code> <p>Vertical quadrupole angle error [micro radian].</p> <code>quadrupole_roll</code> <code>float</code> <p>Quadrupole roll around longitudinal axis [micro radian].</p> <code>cavity_x</code> <code>float</code> <p>Horizontal structure position error [micro m].</p> <code>cavity_realign_x</code> <code>float</code> <p>Horizontal structure position error after realignment [micro m].</p> <code>cavity_y</code> <code>float</code> <p>Vertical structure position error [micro m].</p> <code>cavity_realign_y</code> <code>float</code> <p>Vertical structure position error after realignment [micro m].</p> <code>cavity_xp</code> <code>float</code> <p>Horizontal structure angle error [micro radian].</p> <code>cavity_yp</code> <code>float</code> <p>Vertical structure angle error [micro radian].</p> <code>cavity_dipole_x</code> <code>float</code> <p>Horizontal dipole kick [rad*GeV].</p> <code>cavity_dipole_y</code> <code>float</code> <p>Vertical dipole kick [rad*GeV].</p> <code>piece_x</code> <code>float</code> <p>Horizontal structure piece error [micro m].</p> <code>piece_xp</code> <code>float</code> <p>Horizontal structure piece angle error [micro radian].</p> <code>piece_y</code> <code>float</code> <p>Vertical structure piece error [micro m].</p> <code>piece_yp</code> <code>float</code> <p>Vertical structure piece angle error [micro radian].</p> <code>bpm_x</code> <code>float</code> <p>Horizontal BPM position error [micro m].</p> <code>bpm_y</code> <code>float</code> <p>Vertical BPM position error [micro m].</p> <code>bpm_xp</code> <code>float</code> <p>Horizontal BPM angle error [micro radian].</p> <code>bpm_yp</code> <code>float</code> <p>Vertical BPM angle error [micro radian].</p> <code>bpm_roll</code> <code>float</code> <p>BPM roll around longitudinal axis [micro radian].</p> <code>sbend_x</code> <code>float</code> <p>Horizontal sbend position error [micro m].</p> <code>sbend_y</code> <code>float</code> <p>Vertical sbend position error [micro m].</p> <code>sbend_xp</code> <code>float</code> <p>Horizontal sbend angle error [micro radian].</p> <code>sbend_yp</code> <code>float</code> <p>Vertical sbend angle error [micro radian].</p> <code>sbend_roll</code> <code>float</code> <p>Sbend roll around longitudinal axis [micro radian].</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.TclCall","title":"<code>TclCall(**command_details)</code>","text":"<p>Run the 'TclCall' command in Placet.</p> <p>Essentially sets up the callback function for the tracking. Not sure when it is invoked (entrance or exit). It works for the beamline ext though.</p> <p>Other Parameters:</p> Name Type Description <code>script</code> <code>str</code> <p>The name of the script to be used as a callback.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.TestFreeCorrection","title":"<code>TestFreeCorrection(**command_details)</code>","text":"<pre><code>    Corresponds to 'TestFreeCorrection' command in Placet TCL\n\n    The full list of the command parameters:\n    machines                                - Number of machines to simulate\n    binlength                               - Number of quadrupoles per bin\n    binoverlap                              - Overlap of bins in no of quadrupoles\n    jitter_y                                - Vertical beam jitter\n    jitter_x                                - Horizontal beam jitter\n    bpm_resolution                  - BPM resolution\n    rf_align                                - Align the RF after the correction?\n    beam                                    - Name of the beam to be used for correction\n    survey                                  - Type of prealignment survey to be used (default Clic)\n    emitt_file                              - Filename for the results (default NULL)\n    wgt0                                    - Weight for the BPM position\n    wgt1                                    - Weight for the BPM resolution\n    pwgt                                    - Weight for the old quadrupole position\n    quad_set0                               - List of quadrupole strengths to be used\n    quad_set1                               - List of quadrupole strengths to be used\n    quad_set2                               - List of quadrupole strengths to be used\n    load_bins                               - File with bin information to be loaded\n    save_bins                               - File with bin information to be loaded\n</code></pre>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.TestFreeCorrection--to-do","title":"TO DO","text":"<pre><code>    Add description\n</code></pre> <p>Not tested</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.TestMeasuredCorrection","title":"<code>TestMeasuredCorrection(**command_details)</code>","text":"<p>Run the 'TestMeasuredCorrection' command in Placet.</p> <p>It performes a complicated (and not obvious) correction of the beamline alignment. Normally is used for the DFS.</p> <p>The parameters' description is taken from the Placet Manual.</p> <p>Other Parameters:</p> Name Type Description <code>machines</code> <code>int</code> <p>Number of machines to simulate. Default is 1.</p> <code>start</code> <code>int</code> <p>First element to be corrected.</p> <code>end</code> <code>int</code> <p>Last element but one to be corrected (&lt;0: go to the end).</p> <code>binlength</code> <code>int</code> <p>Number of quadrupoles per bin.</p> <code>correct_full_bin</code> <code>int</code> <p>If not zero the whole bin will be corrected.</p> <code>binoverlap</code> <code>int</code> <p>Overlap of bins in no of quadrupoles.</p> <code>jitter_x</code> <code>float</code> <p>Vertical beam jitter [micro meter].</p> <code>jitter_y</code> <code>float</code> <p>Horizontal beam jitter [micro meter].</p> <code>bpm_resolution</code> <code>float</code> <p>BPM resolution [micro meter].</p> <code>rf_align</code> <code>int(?)</code> <p>Align the RF after the correction. (?)</p> <code>no_acc</code> <code>int(?)</code> <p>Switch RF off in corrected subsection. (?)</p> <code>beam0</code> <code>str</code> <p>Name of the main beam to be used for correction.</p> <code>beam1</code> <code>str</code> <p>Name of the first help beam to be used for correction.</p> <code>beam2</code> <code>str</code> <p>Name of the second help beam to be used for correction.</p> <code>cbeam0</code> <code>str</code> <p>Name of the main beam to be used for correction.</p> <code>cbeam1</code> <code>str</code> <p>Name of the first help beam to be used for correction.</p> <code>cbeam2</code> <code>str</code> <p>Name of the second help beam to be used for correction.</p> <code>gradient1</code> <code>float</code> <p>Gradient for beam1.</p> <code>gradient2</code> <code>float</code> <p>Gradient for beam2.</p> <code>survey</code> <code>str</code> <p>Type of prealignment survey to be used defaults to CLIC.</p> <code>emitt_file</code> <code>str</code> <p>Filename for the results defaults to NULL (no output).</p> <code>wgt0</code> <code>float</code> <p>Weight for the BPM position.</p> <code>wgt1</code> <code>float</code> <p>Weight for the BPM resolution.</p> <code>wgt2</code> <code>float</code> <p>Second weight for the BPM resolution.</p> <code>pwgt</code> <code>float</code> <p>Weight for the old position.</p> <code>quad_set0</code> <code>list(?)</code> <p>List of quadrupole strengths to be used.</p> <code>quad_set1</code> <code>list(?)</code> <p>List of quadrupole strengths to be used.</p> <code>quad_set2</code> <code>list(?)</code> <p>List of quadrupole strengths to be used.</p> <code>load_bins</code> <code>str</code> <p>File with bin information to be loaded.</p> <code>save_bins</code> <code>str</code> <p>File with bin information to be stored.</p> <code>gradient_list0</code> <code>list(?)</code> <p>Cavity gradients for beam 0.</p> <code>gradient_list1</code> <code>list(?)</code> <p>Cavity gradients for beam 1.</p> <code>gradient_list2</code> <code>list(?)</code> <p>Cavity gradients for beam 2.</p> <code>bin_iterations</code> <code>int</code> <p>Number of iterations for each bin.</p> <code>beamline_iterations</code> <code>int</code> <p>Number of iterations for each machine.</p> <code>correctors</code> <code>list</code> <p>List of correctors to be used.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The tracking results after running TestSimpleCorrection</p> <p>The columns of the resulting DataFrame: ['correction', 'beam', 'survey', 'positions_file', 'emittx', 'emitty']</p> <p>The number of rows correspond to the number of the machines simulated.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.TestNoCorrection","title":"<code>TestNoCorrection(**command_details)</code>","text":"<p>Run the 'TestNoCorrection' command in Placet.</p> <p>It is used to do the beam tracking without applying any corrections.</p> <p>The default time to executing each command in the chain here is set to 20s (might be changed later).  Parameters' description is taken from Placet manual.</p> <p>Other Parameters:</p> Name Type Description <code>machines</code> <code>int</code> <p>Number of machines to simulate. Defauls is 1.</p> <code>beam</code> <code>str</code> <p>Name of the beam to be used for tracking. Required</p> <code>survey</code> <code>str</code> <p>Type of prealignment survey to be used. Default is <code>None</code>. It could be either built-in surveys from Placet, like  <pre><code>[\"None\", \"Zero\", \"Clic\", \"Nlc\", \"Atl\", \"AtlZero\", \"Atl2\", \"AtlZero2,\n\"Earth\"]\n</code></pre> or any procedure that was declared in Placet prior to the current function call. The list of Placet built-in surveys can be accessed at <code>Placet.surveys</code>.</p> <code>emitt_file</code> <code>str</code> <p>Filename for the results' file. Defaults to NULL (no output).</p> <code>bpm_res</code> <code>float</code> <p>BPM resolution. Default is 0.0.</p> <code>format</code> <code>float</code> <p>Format of the file output. (?)</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The tracking results after running TestNoCorrection.</p> <p>The columns of the resulting <code>DataFrame</code>: <code>['correction', 'beam', 'survey', 'positions_file', 'emittx', 'emitty']</code> The number of rows correspond to the number of the machines simulated.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.TestRfAlignment","title":"<code>TestRfAlignment(**command_details)</code>","text":"<p>Run the 'TestRfAlignment' command in Placet.    </p> <p>It performs the RF alignment on the beamline.</p> <p>The command TestRfAlignment does not produce any output inside Placet.</p> <p>Other Parameters:</p> Name Type Description <code>beam</code> <code>str</code> <p>Name of the beam to be used for correction. Required</p> <code>testbeam</code> <code>str</code> <p>Name of the beam to be used for evaluating the corrected beamline.</p> <code>machines</code> <code>int</code> <p>Number of machines.</p> <code>binlength</code> <code>int</code> <p>Length of the correction bins.</p> <code>wgt0</code> <code>float</code> <p>Weight for the BPM position.</p> <code>wgt1</code> <code>float</code> <p>Weight for the BPM resolution.</p> <code>pwgt</code> <code>float</code> <p>Weight for the old position.</p> <code>girder</code> <code>int</code> <p>Girder alignment model:  0 - none; 1 - per girder; 2 - per bin</p> <code>bpm_resolution</code> <code>float</code> <p>BPM resolution [micro meter].</p> <code>survey</code> <code>str</code> <p>Type of prealignment survey to be used.</p> <code>emitt_file</code> <code>str</code> <p>Filename for the results defaults to NULL (no output).</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.TestSimpleCorrection","title":"<code>TestSimpleCorrection(**command_details)</code>","text":"<p>Run the 'TestSimpleCorrection' command in Placet.</p> <p>It is used to apply the one-to-one (1-2-1) alignmet to the beamline.</p> <p>The default time to executing each command in the chain is set to 120s (might be changed later). Parameters' description is taken from the Placet manual.</p> <p>Other Parameters:</p> Name Type Description <code>beam</code> <code>str</code> <p>Name of the beam to be used for correction. Required</p> <code>machines</code> <code>int</code> <p>Number of machines to simulate. Default is 1.</p> <code>start</code> <code>int</code> <p>First element to be corrected.</p> <code>end</code> <code>int</code> <p>Last element but one to be corrected (&lt;0: go to the end).</p> <code>interleave</code> <code>int</code> <p>Used to switch on interleaved bins (correcting only focusing quadrupoles). (?)</p> <code>binlength</code> <code>int</code> <p>Number of quadrupoles per bin.</p> <code>binoverlap</code> <code>int</code> <p>Overlap of bins in no of quadrupoles.</p> <code>jitter_x</code> <code>float</code> <p>Vertical beam jitter [micro meter].</p> <code>jitter_y</code> <code>float</code> <p>Horizontal beam jitter [micro meter].</p> <code>bpm_resolution</code> <code>float</code> <p>BPM resolution [micro meter].</p> <code>testbeam</code> <code>str</code> <p>Name of the beam to be used for evaluating the corrected beamline.</p> <code>survey</code> <code>str</code> <p>Type of prealignment survey to be used.</p> <code>emitt_file</code> <code>str</code> <p>Filename for the results.</p> <code>bin_last</code> <code>str</code> <p>Filename for the results.</p> <code>bin_file_out</code> <code>str</code> <p>Filename for the bin information.</p> <code>bin_file_in</code> <code>str</code> <p>Filename for the bin information.</p> <code>correctors</code> <code>list</code> <p>List of correctors to be used.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>The tracking results after running TestSimpleCorrection</p> <p>The columns of the resulting DataFrame: ['correction', 'beam', 'survey', 'positions_file', 'emittx', 'emitty']</p> <p>The number of rows correspond to the number of the machines simulated.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.TwissMain","title":"<code>TwissMain(**command_details)</code>","text":"<p>Run 'TwissMain' command in Placet.</p> <p>Not sure if it even works. Last checks showed it produces a blank file.</p> <p>Other Parameters:</p> Name Type Description <code>file</code> <code>str</code> <p>The name of the file to write the Twiss.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.TwissPlotStep","title":"<code>TwissPlotStep(**command_details)</code>","text":"<p>Run \"TwissPlotStep\" command in Placet.</p> <p>Evaluates the Twiss parameters along the beamline and saves them into a file.</p> <p>Other Parameters:</p> Name Type Description <code>beam</code> <code>str</code> <p>Name of the beam to use for the calculation. Required</p> <code>file</code> <code>str</code> <p>Name of the file where to store the results.</p> <code>step</code> <code>float</code> <p>Step size to be taken for the calculation. If less than 0 the parameters will be plotted only in the centres of the quadrupoles.</p> <code>start</code> <code>int</code> <p>(?) First particle for twiss computation.</p> <code>end</code> <code>int</code> <p>(?) Last particle for twiss computation.</p> <code>list</code> <code>List[int]</code> <p>Save the twiss parameters only at the selected elements.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p> <p>The output file produces with this command is composed of:</p> <ol> <li>Element number .</li> <li>s: [m] Distance in the beam line.</li> <li>E(s): energy [GeV] ( central slice or average energy for particle beam).</li> <li>beta_x_m(s) [m] (of central slice ).</li> <li>alpha_x_m(s) [m] (of central slice ).</li> <li>beta_x_i(s) [m] (of average over slices).</li> <li>alpha_x_i(s) [m] (of average over slices).</li> <li>beta_y_m(s) [m] (of central slice ).</li> <li>alpha_y_m(s) [m] (of central slice ).</li> <li>beta_y_i(s) [m] (of average over slices).</li> <li>alpha_y_i(s) [m] (of average over slices).</li> <li>disp_x(s) [m/GeV] (of average over slices).</li> <li>disp_xp(s) [rad/GeV] (of average over slices).</li> <li>disp_y(s) [m/GeV] (of average over slices).</li> <li>disp_yp(s) [rad/GeV] (of average over slices).</li> </ol>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.WriteGirderLength","title":"<code>WriteGirderLength(**command_details)</code>","text":"<p>Run 'WriteGirderLength' command in Placet.</p> <p>Needs to checked</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.Zero","title":"<code>Zero(**command_details)</code>","text":"<p>Run 'Zero' command in Placet.</p> <p>It resets the beamline misalignments to zeros.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.__construct_command","title":"<code>__construct_command(command, command_params, **command_details)</code>","text":"<p>Generic function for creating a <code>PlacetCommand</code>.</p> <ul> <li>The Placet command is constructed and the command parameters are extracted from <code>command_details</code>.</li> <li>The computing/parsing details of the command are extracted from command_details, based on the Placet._exec_params</li> </ul> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Command name.</p> required <code>command_params</code> <code>List[str]</code> <p>The full list of the arguments the corresponding command in the Placet TCL can take.</p> required <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.__set_puts_command","title":"<code>__set_puts_command(command, command_params, **command_details)</code>","text":"<p>Generic function for executing the \"set-put\" chain of commands in Placet.</p> <p>Eg: <pre><code>set tmp [command param1 param2 ..]\nputs $tmp\n</code></pre> The data read with the last <code>puts</code> is returned.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Command name.</p> required <code>command_params</code> <code>List[str]</code> <p>The full list of the arguments the corresponding command in the Placet can take.</p> required <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.declare_proc","title":"<code>declare_proc(proc, **command_details)</code>","text":"<p>Declare a custom procedure in Placet.</p> <p>Parameters:</p> Name Type Description Default <code>proc</code> <code>Callable</code> <p>The function in Python.</p> <p>The content of the created procedure consists of the Placet commands that Python runs. The parameter <code>addditional_lineskip = 0</code> is passed, since the commands within <code>proc()</code> environment in Placet do not produce any output.</p> <p>The function used for proc declaration should not have any return value, otherwise the execution is going to be blocked.</p> required <p>Other Parameters:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the created procedure in Placet. If is not defined, the <code>proc.__name__</code> is used as the name.</p> <p>Other arguments accepted are inherited from <code>PlacetCommand</code> but some of them will be forcely overwritten. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.get_element_transverse_matrix","title":"<code>get_element_transverse_matrix(index, **command_details)</code>","text":"<p>Evaluate the Transfer matrix of a given element.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>An element ID.</p> required <p>Other Parameters:</p> Name Type Description <code>beamline</code> <code>str</code> <p>A name of the beamline.</p> <p>Returns:</p> Type Description <code>List[float]</code> <p>Resulting transfer matrix.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.puts","title":"<code>puts(variable, **command_details)</code>","text":"<p>Run the 'puts' command in Placet.</p> <p>Prints the given variable in Placet, reads it and returns.</p> <p>Parameters:</p> Name Type Description Default <code>variable</code> <code>str</code> <p>Variable to evaluate</p> required <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p> <p>Returns:</p> Type Description <code>str</code> <p>The value Placet returned.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.set","title":"<code>set(variable, value, **command_details)</code>","text":"<p>Run 'set' command in TCL.</p> <p>Set the given variable to the given value in Placet.</p> <p>Parameters:</p> Name Type Description Default <code>variable</code> <code>str</code> <p>Variable to to be set.</p> required <code>value</code> <code>float</code> <p>The value the variable to be set to.</p> required <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p> <p>Returns:</p> Type Description <code>value</code> <p>The value that was set.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.set_list","title":"<code>set_list(name, **command_details)</code>","text":"<p>Declare the dictionary in Placet</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the dictionary.</p> required <p>All the keyword variables provided are going to be declared int the dictionary in Placet.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.source","title":"<code>source(filename, **command_details)</code>","text":"<p>Run the 'source' command in Placet.</p> <p>'Sources' the given file into Placet.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Name of the file to read.</p> required <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p>"},{"location":"placet/placetwrap/#placetmachine.placet.placetwrap.Placet.wake_calc","title":"<code>wake_calc(filename, charge, a, b, sigma_z, n_slices, **command_details)</code>","text":"<p>Run a custom function calc{} from \"wake_calc.tcl\" in Placet.</p> <p>It is used to evaluate the wakefields and write the output to a file. The resulting file contains the slices weights and wakefiled parameters.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to produce.</p> required <code>charge</code> <code>float</code> <p>The bunch charge.</p> required <code>a</code> <code>float</code> <p>To check.</p> required <code>b</code> <code>float</code> <p>To check.</p> required <code>sigma_z</code> <code>float</code> <p>Bunch length in microns.</p> required <code>n_slices</code> <code>int</code> <p>Number of slices.</p> required <p>Other arguments accepted are inherited from <code>PlacetCommand</code>. See the list optional parameters.</p> <p>Returns:</p> Type Description <code>str</code> <p>The name of the generated file.</p>"},{"location":"placet/pyplacet/","title":"Placet documentation","text":""},{"location":"placet/pyplacet/#placetmachine.placet.pyplacet.Placetpy","title":"<code>Placetpy(name='placet', **kwargs)</code>","text":"<p>         Bases: <code>Communicator</code></p> <p>A class used to interact with Placet process running in background.</p> <p>Extends <code>Communicator</code> to run Placet and its commands of the proper format.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the process to start. Should be the command starting Placet interactive shell.</p> <code>'placet'</code> <p>Other Parameters:</p> Name Type Description <code>show_intro</code> <code>bool</code> <p>If <code>True</code> (defauls is <code>True</code>), prints the welcome message of Placet at the start.</p> <code>debug_mode</code> <code>bool</code> <p>If <code>True</code> (default is <code>False</code>), runs <code>Placetpy</code> in debug mode.</p> <code>save_logs</code> <code>bool</code> <p>If <code>True</code> (default is <code>True</code>) , invoking <code>save_debug_info()</code>.</p> <code>send_delay</code> <code>float</code> <p>The time delay before each data transfer to a child process (sometimes needed for stability). Default is <code>Placetpy._BUFFER_MAXSIZE</code>.</p>"},{"location":"placet/pyplacet/#placetmachine.placet.pyplacet.Placetpy.readline","title":"<code>readline(timeout=Communicator._BASE_TIMEOUT)</code>","text":"<p>Read the line from Placet process.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Timeout of the reader before raising the exception. No effect anymore. The parameter is kept for compatibility.</p> <code>Communicator._BASE_TIMEOUT</code> <p>Returns:</p> Type Description <code>str</code> <p>The line of the data received from the child process.</p>"},{"location":"placet/pyplacet/#placetmachine.placet.pyplacet.Placetpy.restart","title":"<code>restart()</code>","text":"<p>Restart the child process.</p>"},{"location":"placet/pyplacet/#placetmachine.placet.pyplacet.Placetpy.run_command","title":"<code>run_command(command, skipline=True)</code>","text":"<p>Run the given command in Placet.</p> <p>Does not return any value. The output after the execution is up to the user to read with <code>readline()</code> or <code>readlines()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>PlacetCommand</code> <p>The command to pass to Placet.</p> required <code>skipline</code> <code>bool</code> <p>If <code>True</code> invokes <code>skipline()</code> to read the command back from the buffer. This option is needed when the process writes the command it 'writes' into the out buffer.</p> <code>True</code>"},{"location":"placet/pyplacet/#placetmachine.placet.pyplacet.PlacetCommand","title":"<code>PlacetCommand(command, **kwargs)</code>","text":"<p>A class used to classify the Placet commands.</p> <p>Attributes:</p> Name Type Description <code>command</code> <code>str</code> <p>A line with Placet command, including all the options</p> <code>timeout</code> <code>float</code> <p>The typical time margin for the execution time of the command.  Is passed further to <code>Placetpy</code> - if execution takes longer than timeout, throws an exception</p> <code>type</code> <code>str</code> <p>The type of the command. Corresponds to the command name, without any options</p> <code>additional_lineskip</code> <code>int</code> <p>The number of lines that the command produces when executed.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The command including all the options as a string.</p> required <p>Other Parameters:</p> Name Type Description <code>timeout</code> <code>Optional[float]</code> <p>A timeout for the command execution in Placet.</p> <code>type</code> <code>str</code> <p>A command type. Correspons to the command name without any parameters. If not provided, is evaluated automatically.</p> <code>additional_lineskip</code> <code>int</code> <p>The number of lines of the Placet output to skip after writing the command. If not provided, is evaluated automatically based on the type of a command.</p> <code>expect_before</code> <code>bool</code> <p>If <code>True</code> (default is <code>True</code>), <code>expect</code> command is invoked before 'writing' the command.</p> <code>expect_after</code> <code>bool</code> <p>If <code>True</code> (default is <code>False</code>), <code>expect</code> command is invoked after 'writing' the command.</p> <code>no_expect</code> <code>bool</code> <p>If <code>True</code> (default is <code>False</code>), <code>expect</code> command for the command prompt is not invoked neither before or after doing 'writing'. Overwrites <code>expect_before</code> and <code>expect_after</code> parameters.</p>"}]}